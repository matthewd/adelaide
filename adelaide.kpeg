%% name = Adelaide::Parser
%% {

# The big ambiguities:
#  / -- divide vs regexp
#  : -- symbol vs ternary vs "then" vs ::
#  << -- heredoc vs lshift

  attr_accessor :ast
  attr_accessor :line_offset
  def lineno; @lines[pos] ||= current_line + (@line_offset || 0); end

  attr_accessor :heredocs

  def setup
    @heredocs = []
    @lines = {}
  end

  SPACES = ["\t", "\n", "\v", "\f", "\r", ' ', "\r\n"]
  NEWLINE = ["\r", "\n", "\r\n"]
  def string_end(c)
    case c
    when '('; ')'
    when '['; ']'
    when '<'; '>'
    when '{'; '}'
    else; c
    end
  end

  class Cx
    def self.strict; new.strict; end
    def self.no_do; new.no_do; end

    def initialize
      @strict = false
      @no_do = false
    end

    def strict?; @strict; end
    def no_do?; @no_do; end

    def strict; with(:strict); end
    def no_do; with(:no_do); end

    def with(t)
      x = dup
      x.instance_variable_set(:"@#{t}", true)
      x
    end

    def unstrict; without(:strict); end
    def unno_do; without(:no_do); end

    def without(t)
      x = dup
      x.instance_variable_set(:"@#{t}", false)
      x
    end

    def left
      self
    end
    def right
      unstrict
    end

    def eql?(other)
      other.strict? == strict? &&
        other.no_do? == no_do?
    end
    def hash
      n = 1
      n <<= 1; n |= 1 if strict?
      n <<= 1; n |= 1 if no_do?
      n
    end
  end

  AST = ::Rubinius::AST


  # Iron out consecutive literal string-parts, then decide whether this
  # is a dstr
  def AST.str(line, parts, static=AST::StringLiteral, dynamic=AST::DynamicString, *extra)
    x = [""]
    parts.each do |part|
      if ::String === x.last && ::String === part
        x.last << part
      elsif part
        x << part.dup
      else
        x << ""
      end
    end
    front = ""
    front = x.shift if ::String === x.first
    x = x.map {|part| ::String === part ? AST::StringLiteral.new(line, part) : part }

    if x.empty?
      if block_given?
        static.new(line, yield(front), *extra)
      else
        static.new(line, front, *extra)
      end
    else
      dynamic.new(line, front, x, *extra)
    end
  end

  def regex_flags(s)
    kcode = 0
    options = 0
    s.split(//).each do |c|
      case c
      when 'i'; options |= 1
      when 'x'; options |= 2
      when 'm'; options |= 4
      when 'o'; #options |= 8192
      when 'G'; options |= 256
      when 'g'; options |= 128
      when 'n'; kcode = 16
      when 'e'; kcode = 32
      when 's'; kcode = 48
      when 'u'; kcode = 64
      else
      end
    end
    options | kcode
  end

  def escaped_char(c)
    case c
    when 'n'; ?\n
    when 't'; ?\t
    when 'r'; ?\r
    when 'f'; ?\f
    when 'v'; ?\v
    when 'a'; ?\a
    when 'e'; ?\e
    when 'b'; ?\b
    when 's'; ?\s
    else; c[0]
    end
  end


  Heredoc = Struct.new(:target, :stop, :indent, :dynamic)
  class Heredoc
    def stop?(line)
      (@indent ? line.strip : line.chomp) == @stop
    end
    def append(strings)
      list = strings.flatten

      @target.string << list.shift while String === list.first
      return if list.empty?

      until list.empty?
        if String === @target.array.last && String === list.first
          @target.array.last << list.shift
        elsif String === list.first
          @target.array << list.shift.dup
        else
          item = list.shift
          @target.array << item
        end
      end

      @target.array.each_with_index do |item, idx|
        @target.array[idx] = AST::StringLiteral.new(@target.line, item) if String === item
      end
    end
  end

  def heredoc(line, stop, indent, klass=nil)
    dynamic = !!klass
    if dynamic
      s = klass.new(line, "", [])
    else
      s = AST::StringLiteral.new(line, "")
    end

    @heredocs << Heredoc.new(s, stop, indent, dynamic)
    s
  end
  def pop_heredoc
    @heredocs.pop
  end


  def command_candidate?(candidate)
    case candidate
    when AST::Send, AST::ConstantAccess
      true
    when AST::Return
      candidate.value.nil?
    when AST::Next
      candidate.value.nil?
    when AST::Break
      candidate.value.nil?
    #when AST::Yield
    #  candidate.value.nil?
    else
      false
    end
  end

  def as_command(call, args, block)
    case call
    when AST::Send
      if args
        x = AST::SendWithArguments.new(call.line, call.receiver, call.name, args, call.privately)
      else
        x = call
      end
      x.block = block
      transform(x)
    when AST::ConstantAccess
      if args
        x = AST::SendWithArguments.new(call.line, AST::Self.new(call.line), call.name, args, true)
      else
        x = AST::Send.new(call.line, AST::Self.new(call.line), call.name, true)
      end
      x.block = block
      transform(x)
    when AST::Return, AST::Next, AST::Break
      call.value = disarray(args)
      call
    else
      raise call.inspect
    end
  end

  def to_assign(line, lhs, rhs=nil, op=nil)
    if op == :and || op == :or
      special_op, op = op, nil
    end

    if AST::Send === lhs && lhs.vcall_style
      lhs = AST::LocalVariableAccess.new(lhs.line, lhs.name)
    end

    assignment =
      case lhs
      # This must come before AST::Send, because thats our superclass.
      when AST::SendWithArguments
        return nil unless lhs.name == :[]
        args =
          if !lhs.arguments.array.empty? && lhs.arguments.splat
            AST::ConcatArgs.new(line, AST::ArrayLiteral.new(line, lhs.arguments.array), lhs.arguments.splat.value)
          elsif lhs.arguments.splat
            lhs.arguments.splat
          else
            AST::ArrayLiteral.new(line, lhs.arguments.array)
          end

        if op || special_op
          return AST::OpAssign1.new(line, lhs.receiver, args, (op || special_op), rhs)
        else
          AST::ElementAssignment.new(line, lhs.receiver, args)
        end

      when AST::Send
        if op || special_op
          return AST::OpAssign2.new(line, lhs.receiver, lhs.name, (op || special_op), rhs)
        else
          AST::AttributeAssignment.new(line, lhs.receiver, lhs.name, nil)
        end

      when AST::LocalVariableAccess
        rhs = binop(line, op, lhs, rhs) if op
        AST::LocalVariableAssignment.new(line, lhs.name, rhs)

      when AST::ConstantAccess
        rhs = binop(line, op, lhs.dup, rhs) if op
        AST::ConstantAssignment.new(line, lhs, rhs)

      when AST::ToplevelConstant, AST::ScopedConstant
        return nil if op
        AST::ConstantAssignment.new(line, lhs, rhs)

      when AST::InstanceVariableAccess
        rhs = binop(line, op, lhs, rhs) if op
        AST::InstanceVariableAssignment.new(line, lhs.name, rhs)

      when AST::ClassVariableAccess
        rhs = binop(line, op, lhs, rhs) if op
        AST::ClassVariableAssignment.new(line, lhs.name, rhs)

      when AST::GlobalVariableAccess
        rhs = binop(line, op, lhs, rhs) if op
        AST::GlobalVariableAssignment.new(line, lhs.name, rhs)

      when AST::BackRef
        rhs = binop(line, op, lhs, rhs) if op
        AST::GlobalVariableAssignment.new(line, :"$#{lhs.kind}", rhs)

      when AST::CurrentException
        rhs = binop(line, op, lhs, rhs) if op
        AST::GlobalVariableAssignment.new(line, :$!, rhs)
      end

    case special_op
    when :and
      AST::OpAssignAnd.new(line, lhs, assignment)
    when :or
      AST::OpAssignOr.new(line, lhs, assignment)
    else
      assignment
    end
  end

  def set_mrhs(lhs, rhs)
    if lhs.splat && !lhs.left
      set_rhs lhs, AST::ArrayLiteral.new(rhs.line, [rhs])
    else
      set_rhs lhs, AST::ToArray.new(rhs.line, rhs)
    end
  end
  def set_rhs(lhs, rhs)
    case lhs
    when AST::MultipleAssignment
      splat = lhs.splat || lhs.empty_splat
      splat = splat.value if AST::SplatAssignment === splat
      lhs = AST::MultipleAssignment.new(lhs.line, lhs.left, rhs, splat)
    when AST::ElementAssignment
      lhs = lhs.dup
      if lhs.arguments.splat
        if lhs.arguments.array.empty?
          lhs.arguments = AST::PushArgs.new(lhs.line, lhs.arguments.splat, rhs)
        else
          lhs.arguments = AST::PushArgs.new(lhs.line, AST::ConcatArgs.new(lhs.line, AST::ArrayLiteral.new(lhs.line, lhs.arguments.array), lhs.arguments.splat.value), rhs)
        end
      else
        lhs.arguments.array << rhs
      end
    when AST::AttributeAssignment
      lhs = lhs.dup
      lhs.arguments.array << rhs
    else
      lhs = lhs.dup
      lhs.value = rhs
    end
    lhs
  end


  def blockify(line, array)
    if array.size == 1 #&& !(AST::Begin === array.first)
      array.first
    elsif array.size == 0
      AST::NilLiteral.new(line)
    else
      AST::Block.new(line, array)
    end
  end
  def disarray(array)
    if AST::ArrayLiteral === array && array.body.size == 1
      array = array.body.first
    elsif AST::SplatValue === array
      array = AST::SValue.new(array.line, array)
    end
    array
  end

  def magic_conditional(condition)
    case condition
    when AST::RegexLiteral
      AST::Match.new(condition.line, condition.source, condition.options)
    when AST::DynamicRegex
      AST::Match2.new(condition.line, condition, AST::GlobalVariableAccess.new(condition.line, :$_))
    when AST::RangeExclude
      AST::Flip3.new(condition.line, condition.start, condition.finish)
    when AST::Range
      AST::Flip2.new(condition.line, condition.start, condition.finish)
    else
      condition
    end
  end

  def condition_block(line, condition, true_body, false_body)
    if AST::Not === condition
      condition = condition.value
      true_body, false_body = false_body, true_body
    end

    AST::If.new(line, magic_conditional(condition), true_body, false_body)
  end

  def conditional_loop(line, condition, body, stop_when_false, trailer=false)
    if AST::Not === condition
      condition = condition.value
      stop_when_false = !stop_when_false
    end

    if stop_when_false
      AST::While.new(line, magic_conditional(condition), body, !trailer || !(AST::Begin === body))
    else
      AST::Until.new(line, magic_conditional(condition), body, !trailer || !(AST::Begin === body))
    end
  end

  def transform(fcall)
    # TODO: Invoke the Melbourne-defined transforms
    fcall
  end

  def idempotent?(stmt)
    # Apparently we dont remove numbers, though?
    AST::StringLiteral === stmt || AST::SymbolLiteral === stmt
  end


  def match(line, left, right)
    return AST::Match2.new(line, left, right) if AST::RegexLiteral === left || AST::DynamicRegex === left
    return AST::Match3.new(line, right, left) if AST::RegexLiteral === right || AST::DynamicRegex === right
    binop(line, :=~, left, right)
  end
  def no_match(line, left, right)
    AST::Not.new(line, match(line, left, right))
  end
  
  def not_equal(line, left, right)
    AST::Not.new(left.line, binop(left.line, :==, left, right))
  end


  RESERVED = %w(
    __LINE__ __FILE__ BEGIN END alias and begin break case class def
    defined? do else elsif end ensure false for in module next nil not
    or redo rescue retry return self super then true undef when yield
    if unless while until
  )
}

eof = !.

space_element = hspace | newline | comment | escaped_newline
escaped_newline = "\\" newline
comment = /#[^\r\n]*/
hspace = /[ \t\v\f]+/

any_whitespace = /[ \t\n\r\n]/

wsp = space_element+
- = space_element*
sp = (hspace | comment | escaped_newline)+
s = (hspace | comment | escaped_newline)*


root = { setup } { line = lineno } rd_doc* program:r - eof { @ast = r }
program = statements

statements = - { line = lineno } stmts:s opt_terms { blockify(line, s) }

block_body = { l1 = lineno } statements:b - { l2 = lineno } (- rescue_clause)?:resc - else_clause?:els - { l3 = lineno } ensure_clause?:ens
               { b = AST::Rescue.new(l2, AST::NilLiteral === b ? nil : b, resc, els) if resc || els; b = AST::Ensure.new(l3, b, ens) if ens; b = AST::Block.new(l1, []) if AST::NilLiteral === b; b = AST::Block.new(l1, [b]) unless AST::Block === b; b }

stmts = stmts:l terms - statement:s { l.pop if idempotent?(l.last); l + [s] }
      | statement:s { [s] }
      | none { [] }

statement = statement:v s { line = lineno } kw("if") - expr(Cx.new):c { condition_block(lineno, c, v, nil) }
          | statement:v s { line = lineno } kw("unless") - expr(Cx.new):c { condition_block(lineno, c, nil, v) }
          | statement:v s { line = lineno } kw("while") - expr(Cx.new):c { conditional_loop(line, c, v, true, true) }
          | statement:v s { line = lineno } kw("until") - expr(Cx.new):c { conditional_loop(line, c, v, false, true) }
          | statement:v s { line = lineno } kw("rescue") - statement:f { AST::Rescue.new(line, v, AST::RescueCondition.new(line, nil, f, nil), nil) }
          | alias_statement:a { a }
          | { line = lineno } kw("undef") - undef_list(lineno):l { blockify(line, l) }
          | { line = lineno } kw("BEGIN") - "{" - statements:s - "}"
          | { line = lineno } kw("END") - "{" - statements:s - "}" { x = AST::Send.new(line, AST::Self.new(line), :at_exit, true); x.block = AST::Iter.new(line, nil, s); x }
          | { line = lineno } lhs(Cx.new):l s "=" !"=" !">" !"~" - mrhs:v { set_rhs(l, disarray(v)) }
          | { line = lineno } mlhs:l s "=" !"=" !">" !"~" - mrhs:v { set_rhs(l, v) }
          | { line = lineno } lhs(Cx.new):l s "=" !"=" !">" !"~" - command_call(Cx.new):v { set_rhs(l, v) }
          | { line = lineno } mlhs:l s "=" !"=" !">" !"~" - command_call(Cx.new):v { set_mrhs(l, v) }
          | { line = lineno } mlhs:l s "=" !"=" !">" !"~" - arg(Cx.new):v { set_mrhs(l, v) }
          | { line = lineno } primary(Cx.new):t s op_asgn:o - command_call(Cx.new):v &{ x = to_assign(line,t,v,o) } { x }
          | expr(Cx.new):e { e }

alias_statement = { line = lineno } kw("alias") - fitem:a - fitem:b { AST::Alias.new(lineno, a, b) }
                | { line = lineno } kw("alias") - gvar:a - gvar:b { AST::VAlias.new(lineno, a.to_sym, b.to_sym) }
                | { line = lineno } kw("alias") - gvar:a - !nthref backref:b { AST::VAlias.new(lineno, a.to_sym, b.to_sym) }

expr(cx) = { line = lineno } expr2(cx):l - kw("and") - expr(cx.right):r { AST::And.new(lineno,l,r) }
         | { line = lineno } expr2(cx):l - kw("or") - expr(cx.right):r { AST::Or.new(lineno,l,r) }
         | expr2(cx):e { e }

# This is mostly here to handle the 'a [1] [2] = 3' quirk; we need to be
# fairly fussy about ensuring a command_call has consumed enough input.
fin = term | "}" | ")" | kw("and") | kw("or") | kw("end") | kw("if") | kw("unless") | kw("while") | kw("until") | kw("rescue") | kw("else") | kw("elsif") | kw("when") | kw("ensure")
expr2(cx) = { line = lineno } kw("not") - expr2(cx.right):e { AST::Not.new(lineno,e) }
          | { line = lineno } "!" - expr2(cx.right):e { AST::Not.new(lineno,e) }
          | command_call(cx):c &(s fin) { c }
          | arg(cx):a { a }


command_call(cx) = !{ cx.no_do? } block_call(cx):t dot_or_colon - { line = lineno } operation2:n command_args(cx.right):a { x = AST::SendWithArguments.new(line, t, n.to_sym, a[0]); x.block = a[1]; transform(x) }
                 | !{ cx.no_do? } block_call(cx):c command_args(cx.right):a &{ command_candidate?(c) } { as_command(c, a[0],a[1]) }
                 | !{ cx.no_do? } block_call(cx):c { c }
                 | command(cx):c { transform(c) }
                 | kw("return") s command_call(cx.right):v { AST::Return.new(lineno, v) }
                 | kw("return") s loose_call_args(cx.right):v &{ v[1].nil? } { AST::Return.new(lineno, disarray(v[0])) }
                 | kw("break") s command_call(cx.right):v { AST::Break.new(lineno, v) }
                 | kw("break") s loose_call_args(cx.right):v &{ v[1].nil? } { AST::Break.new(lineno, disarray(v[0])) }
                 | kw("next") s command_call(cx.right):v { AST::Next.new(lineno, v) }
                 | kw("next") s loose_call_args(cx.right):v &{ v[1].nil? } { AST::Next.new(lineno, disarray(v[0])) }


cmd_brace_block = { line = lineno } "{" - opt_block_var:v - statements:s - "}" { AST::Iter.new(line, v, b) }

command(cx) = &{ false }
            | { line = lineno } kw("super") command_args(cx):v { x = AST::Super.new(line, v[0]); x.block = v[1]; x }
            | { line = lineno } kw("yield") command_args(cx):v { x = AST::Yield.new(line, v[0], true); x.block = v[1]; x }
            | primary(cx):c &{ command_candidate?(c) } command_args(cx):a (s cmd_brace_block)?:b &{ !a[1] || !b } { as_command(c, a[0], a[1] || b) }

mlhs = { line = lineno } "(" - mlhs:i - ")" { i }
     | { line = lineno } mlhs_head:l - mlhs_item:i { AST::MultipleAssignment.new(line, AST::ArrayLiteral.new(line, l + [i]), nil, nil) }
     | { line = lineno } mlhs_head:l - splat_lhs:i { AST::MultipleAssignment.new(line, AST::ArrayLiteral.new(line, l), nil, i) }
     | { line = lineno } mlhs_head:l { AST::MultipleAssignment.new(line, AST::ArrayLiteral.new(line, l), nil, nil) }
     | { line = lineno } splat_lhs:i { AST::MultipleAssignment.new(line, nil, nil, i) }

mlhs_head = mlhs_head:l - mlhs_item:i - "," { l + [i] }
          | mlhs_item:i - "," { [i] }

mlhs_item = "(" - mlhs:i - ")" { i }
          | mlhs_node(Cx.new):i { i }

mlhs_node_part(cx) = mlhs_node_part(cx):t sp "[" - aref_args:a - "]" { transform(AST::SendWithArguments.new(lineno, t, :[], a)) }
                   | primary(cx)
mlhs_node(cx) = mlhs_node_part(cx):t &{ x = to_assign(t.line, t) } { x }

lhs(cx) = mlhs_node(cx)

cname = identifier
      | constant

cpath = primary(Cx.new):v &{ AST::ScopedConstant === v || AST::ToplevelConstant === v } ~v
      | constant:c { c.to_sym }

fname = fid
      | identifier:n "="?:q { q ? "#{n}=" : n }
      | constant:n "="?:q { q ? "#{n}=" : n }
      | < opmethod > { text }

fitem = { line = lineno } fname:n { AST::SymbolLiteral.new(line, n.to_sym) }
      | symbol
      | dsym

undef_list(line) = undef_list(line):l s "," - fitem:i { l + [AST::Undef.new(line, i)] }
                 | fitem:i { [AST::Undef.new(line, i)] }

opmethod = "[]="
         | "[]"
         | "<=>"
         | "==="
         | "=="
         | "=~"
         | "<<"
         | ">>"
         | ">="
         | "<="
         | ">"
         | "<"
         | "+@"
         | "-@"
         | "**"
         | "+"
         | "-"
         | "*"
         | "/"
         | "%"
         | "~"
         | "|"
         | "^"
         | "&"
         | "`"

op_asgn = "||=" { :or }
        | "&&=" { :and }
        | < "**="
          | "*="
          | "<<="
          | ">>="
          | "&="
          | "|="
          | "+="
          | "-="
          | "/="
          | "^="
          | "%="
          > { text[0..-2].to_sym }

%% {
  def binop(line, op, lft, rgt)
    transform(AST::SendWithArguments.new(line, lft, op, rgt))
  end
}

arg(cx) = { line = lineno } kw("defined?") - !"(" arg(cx.right):v { AST::Defined.new(line, v) }
        | arg1(cx):c s { line = lineno } "?" - arg(cx.right):t - ":" - arg(cx.right):f { condition_block(line, c, t, f) }
        | arg1(cx)

arg1(cx) = arg2(cx):l s { line = lineno } ".." !"." - arg2(cx.right):r { AST::Range.new(line,l,r) }
         | arg2(cx):l s { line = lineno } "..." - arg2(cx.right):r { AST::RangeExclude.new(line,l,r) }
         | arg2(cx)

arg2(cx) = arg2(cx):l s { line = lineno } "||" !"=" - arg3(cx.right):r { AST::Or.new(line,l,r) }
         | arg3(cx)

arg3(cx) = arg3(cx):l s { line = lineno } "&&" !"=" - arg4(cx.right):r { AST::And.new(line,l,r) }
         | arg4(cx)

arg4(cx) = arg4(cx):l s { line = lineno } "<=>" - arg5(cx.right):r { binop(line,:<=>,l,r) }
         | arg4(cx):l s { line = lineno } "==" !"=" - arg5(cx.right):r { binop(line,:==,l,r) }
         | arg4(cx):l s { line = lineno } "===" - arg5(cx.right):r { binop(line,:===,l,r) }
         | arg4(cx):l s { line = lineno } "!=" - arg5(cx.right):r { not_equal(line, l, r) }
         | arg4(cx):l s { line = lineno } "=~" - arg5(cx.right):r { match(line, l, r) }
         | arg4(cx):l s { line = lineno } "!~" - arg5(cx.right):r { no_match(line, l, r) }
         | arg5(cx)

arg5(cx) = arg5(cx):l s { line = lineno } ">" !"=" !">" - arg6(cx.right):r { binop(line,:>,l,r) }
         | arg5(cx):l s { line = lineno } ">=" - arg6(cx.right):r { binop(line,:>=,l,r) }
         | arg5(cx):l s { line = lineno } "<" !"=" !"<" - arg6(cx.right):r { binop(line,:<,l,r) }
         | arg5(cx):l s { line = lineno } "<=" !">" - arg6(cx.right):r { binop(line,:<=,l,r) }
         | arg6(cx)

arg6(cx) = arg6(cx):l s { line = lineno } "|" !"|" !"=" - arg7(cx.right):r { binop(line,:|,l,r) }
         | arg6(cx):l s { line = lineno } "^" !"=" - arg7(cx.right):r { binop(line,:^,l,r) }
         | arg7(cx)

arg7(cx) = arg7(cx):l s { line = lineno } "&" !"&" !"=" - arg8(cx.right):r { binop(line,:&,l,r) }
         | arg8(cx)

arg8(cx) = arg8(cx):l s { line = lineno } "<<" !"=" - arg9(cx.right):r { binop(line,:<<,l,r) }
         | arg8(cx):l s { line = lineno } ">>" !"=" - arg9(cx.right):r { binop(line,:>>,l,r) }
         | arg9(cx)

arg9(cx) = arg9(cx):l s { line = lineno } "+" !"=" - arg10(cx.right):r { binop(line,:+,l,r) }
         | arg9(cx):l s { line = lineno } "-" !"=" - arg10(cx.right):r { binop(line,:-,l,r) }
         | arg10(cx)

arg10(cx) = arg10(cx):l s { line = lineno } "*" !"*" !"=" - arg11(cx.right):r { binop(line,:*,l,r) }
          | arg10(cx):l s { line = lineno } "/" !"=" - arg11(cx.right):r { binop(line,:/,l,r) }
          | arg10(cx):l s { line = lineno } "%" !"=" - arg11(cx.right):r { binop(line,:%,l,r) }
          | arg11(cx)

arg11(cx) = { line = lineno } "-" !numeric arg11(cx.right):v { transform(AST::Send.new(line, v, :-@)) }
          | { line = lineno } !{ cx.strict? } !numeric "-" - arg11(cx.right):v { transform(AST::Send.new(line, v, :-@)) }
          | { line = lineno } "-" numeric:l s "**" !"=" - arg11(cx.right):r { transform(AST::Send.new(line, binop(line,:**,l,r), :-@)) }
          | arg12(cx)

arg12(cx) = arg13(cx):l s { line = lineno } "**" !"=" - arg11(cx.right):r { binop(line,:**,l,r) }
          | arg13(cx)

arg13(cx) = { line = lineno } "!" - arg11(cx.right):v { transform(AST::Not.new(line, v)) }
          | { line = lineno } "~" - arg11(cx.right):v { transform(AST::Send.new(line, v, :~)) }
          | { line = lineno } "+" arg11(cx.right):v { transform(AST::Send.new(line, v, :+@)) }
          | { line = lineno } !{ cx.strict? } "+" - arg11(cx.right):v { transform(AST::Send.new(line, v, :+@)) }
          | lhs(cx):l s { line = lineno } "=" !"=" !">" !"~" - arg(cx.right):v s kw("rescue") - arg(cx.right):r { set_rhs(l, AST::Rescue.new(line, v, AST::RescueCondition.new(line, nil, r, nil))) }
          | lhs(cx):l s { line = lineno } "=" !"=" !">" !"~" - arg(cx.right):v { set_rhs(l, v) }
          | primary(cx):t s { line = lineno } op_asgn:o - arg(cx.right):v &{ x = to_assign(line, t, v, o) } { x }
          | primary(cx)


aref_args = { line = lineno } assocs(Cx.new):l (- ",")? &(- "]") { AST::ArrayLiteral.new(line, [AST::HashLiteral.new(line, l)]) }
          | { line = lineno } "*" arg(Cx.new):s &(- "]") { AST::SplatValue.new(line, s) }
          | { line = lineno } command(Cx.new):v &(- "]") { transform(v) }
          | { line = lineno } args(Cx.new):l - "," - "*" arg(Cx.new):s &(- "]") { AST::ConcatArgs.new(line, AST::ArrayLiteral.new(line, l), s) }
          | { line = lineno } args(Cx.new):l (- ",")? &(- "]") { AST::ArrayLiteral.new(line, l) }
          | none &(- "]") { nil }

paren_args = "(" - ")" { [nil, nil] }
           | { line = lineno } "(" - call_args(Cx.new):a - ")" { a }
           | { line = lineno } "(" - block_call(Cx.new):b - ")" { [b, nil] }
           | { line = lineno } "(" - args(Cx.new):a - "," - block_call(Cx.new):b - ")" { [AST::ArrayLiteral.new(lineno, a + [b]), nil] }
           | sp paren_args:a { a }

loose_call_args(cx) = !kw("if") !kw("unless") !kw("while") !kw("until") call_args(cx.strict):a ~a
call_args(cx) = &{false} # command(cx):c { [c] }
              | { line = lineno } assocs(cx):h s "," - "*" arg(cx.right):s opt_block_arg(cx.right):b { [AST::ConcatArgs.new(line, AST::ArrayLiteral.new(line, AST::HashLiteral.new(line, h)), s), b] }
              | { line = lineno } assocs(cx):h opt_block_arg(cx.right):b { [AST::ArrayLiteral.new(line, [AST::HashLiteral.new(line, h)]), b] }
              | { line = lineno } args(cx):a s "," - assocs(cx.right):h s "," - "*" arg(cx.right):s opt_block_arg(cx.right):b { [AST::ConcatArgs.new(line, AST::ArrayLiteral.new(line, a + [AST::HashLiteral.new(line, h)]), s), b] }
              | { line = lineno } args(cx):a s "," - assocs(cx.right):h opt_block_arg(cx.right):b { [AST::ArrayLiteral.new(line, a + [AST::HashLiteral.new(line, h)]), b] }
              | { line = lineno } args(cx):a s "," - "*" arg(cx.right):s opt_block_arg(cx.right):b { [AST::ConcatArgs.new(line, AST::ArrayLiteral.new(line, a), s), b] }
              | { line = lineno } arg(cx):i s "," - args(cx.right):a opt_block_arg(cx.right):b { [AST::ArrayLiteral.new(line, [i] + a), b] }
              | command(cx):c { [AST::ArrayLiteral.new(lineno, transform(c)), nil] }
              | { line = lineno } args(cx):a opt_block_arg(cx.right):b { [AST::ArrayLiteral.new(line, a), b] }
              | { line = lineno } "*" arg(cx.right):s opt_block_arg(cx.right):b { [AST::SplatValue.new(line, s), b] }
              | block_arg(cx):b { [nil, b] }


command_args(cx) = !"(" !"[" !"{" !"/" !"%" !"-" !"+" !"<<" s loose_call_args(cx):a { a }

block_arg(cx) = { line = lineno } "&" - arg(cx.right):v { AST::BlockPass.new(line, v) }
opt_block_arg(cx) = - "," - block_arg(cx):v { v }
              | none { nil }

args(cx) = args(cx):l s "," - arg(cx.right):v !(s "=>") { l + [v] }
         | arg(cx):v !(s "=>") { [v] }

mrhs = { line = lineno } args(Cx.new):l s "," - "*" arg(Cx.new):v { AST::ConcatArgs.new(line, AST::ArrayLiteral.new(line, l), v) }
     | { line = lineno } args(Cx.new):l &{ l.size > 1 } { AST::ArrayLiteral.new(line, l) }
     | { line = lineno } "*" arg(Cx.new):v { AST::SplatValue.new(line, v) }


primary(cx) = primary(cx):t "[" - aref_args:a - "]" { transform(AST::SendWithArguments.new(lineno, t, :[], a)) }
            | { line = lineno } primary(cx):t dot_or_colon - operation2:n paren_args:a s brace_block(cx.right):b &{ a[1].nil? } { x = AST::SendWithArguments.new(lineno, t, n.to_sym, a[0]); x.block = b; transform(x) }
            | { line = lineno } primary(cx):t dot_or_colon - operation2:n s brace_block(cx.right):b { x = AST::Send.new(lineno, t, n.to_sym); x.block = b; transform(x) }
            | { line = lineno } primary(cx):t dot_or_colon - operation2:n paren_args:a { x = AST::SendWithArguments.new(lineno, t, n.to_sym, a[0]); x.block = a[1]; transform(x) }
            | { line = lineno } primary(cx):t dot_or_colon - operation3:n { transform(AST::Send.new(lineno, t, n.to_sym)) }
            | { line = lineno } primary(cx):t "::" - constant:c { AST::ScopedConstant.new(lineno, t, c.to_sym) }
            | { line = lineno } primary(cx):t s "." - constant:c { transform(AST::Send.new(lineno, t, c.to_sym)) }
            | { line = lineno } operation:n paren_args:a s brace_block(cx.right):b &{ a[1].nil? } { x = AST::SendWithArguments.new(lineno, AST::Self.new(lineno), n.to_sym, a[0], true); x.block = b; transform(x) }
            | { line = lineno } operation:n paren_args:a { x = AST::SendWithArguments.new(lineno, AST::Self.new(lineno), n.to_sym, a[0], true); x.block = a[1]; transform(x) }
            | { line = lineno } operation:n s brace_block(cx.right):b { x = AST::Send.new(lineno, AST::Self.new(lineno), n.to_sym, true); x.block = b; transform(x) }
            | { line = lineno } kw("super") paren_args:v s brace_block(cx.right):b &{ a[1].nil? } { x = AST::Super.new(lineno, v[0]); x.block = b; x }
            | { line = lineno } kw("super") paren_args:v { x = AST::Super.new(lineno, v[0]); x.block = v[1]; x }
            | { line = lineno } kw("super") s brace_block(cx.right):b { x = AST::ZSuper.new(lineno); x.block = b; x }
            | { line = lineno } kw("super") { AST::ZSuper.new(lineno) }
            | literal
            | strings(cx)
            | xstring
            | regexp(cx)
            | words
            | qwords
            | { line = lineno } !"defined?" fid:n { transform(AST::Send.new(lineno, AST::Self.new(lineno), n.to_sym, true)) }
            | variable
            | { line = lineno } kw("begin") - block_body:b - kw("end") { b.array.size == 0 ? AST::NilLiteral.new(line) : AST::Begin.new(line, b.array.size == 1 ? b.array.first : b) }
            | "(" - expr(Cx.new):e - ")" { e }
            | "(" - statements:s - ")" { s }
            | { line = lineno } "::" - constant:c { AST::ToplevelConstant.new(lineno, c.to_sym) }
            | { line = lineno } "[" - aref_args:a - "]" { a || AST::EmptyArray.new(lineno) }
            | { line = lineno } "{" - assoc_list:l - "}" { AST::HashLiteral.new(lineno, l) }
            | { line = lineno } kw("return") { AST::Return.new(lineno, nil) }
            | { line = lineno } kw("yield") s "(" - call_args(Cx.new):v - ")" { x = AST::Yield.new(lineno, v[0], true); x.block = v[1]; x }
            | { line = lineno } kw("yield") s "(" - ")" { AST::Yield.new(lineno, nil, true) }
            | { line = lineno } kw("yield") { AST::Yield.new(lineno, nil, true) }
            | { line = lineno } kw("defined?") - "(" - expr(Cx.new):v - ")" { AST::Defined.new(lineno, v) }
            | { line = lineno } kw("if") - expr(cx.right):e s then - statements:s - if_tail(cx.right):l - kw("end") { condition_block(lineno, e, s, l) }
            | { line = lineno } kw("unless") - expr(cx.right):e s then - statements:s - else_clause?:f - kw("end") { condition_block(lineno, e, f, s) }
            | { line = lineno } kw("while") - expr(Cx.no_do):e s do - statements:s - kw("end") { conditional_loop(line, e, s, true) }
            | { line = lineno } kw("until") - expr(Cx.no_do):e s do - statements:s - kw("end") { conditional_loop(line, e, s, false) }
            | { line = lineno } kw("case") opt_terms - case_body:b - else_clause?:e - kw("end") { AST::Case.new(lineno, b, e) }
            | { line = lineno } kw("case") - expr(cx.right):v opt_terms - case_body:b - else_clause?:e - kw("end") { AST::ReceiverCase.new(lineno, v, b, e) }
            | { line = lineno } kw("for") - for_var:a - kw("in") - expr(cx.right.no_do):t s do - statements:b - kw("end") { x = AST::Send.new(lineno, t, :each); x.block = AST::For.new(lineno, a, b); transform(x) }
            | { line = lineno } kw("class") - "<<" - expr(cx.right):e term - block_body:b - kw("end") { AST::SClass.new(lineno, e, b.array.size == 0 ? nil : b) }
            | { line = lineno } kw("class") - cpath:n superclass:s - block_body:b - kw("end") { AST::Class.new(lineno, n, s, b.array.size == 0 ? nil : b) }
            | { line = lineno } kw("module") - cpath:n - block_body:b - kw("end") { AST::Module.new(lineno, n, b.array.size == 0 ? nil : b) }
            | { line = lineno } kw("def") - fname:n s f_arglist:a - block_body:b - kw("end") { x = AST::Define.new(lineno, n.to_sym, b); x.arguments = a; x }
            | { line = lineno } kw("def") - singleton:o dot_or_colon - fname:n s f_arglist:a - block_body:b - kw("end") { x = AST::DefineSingleton.new(lineno, o, n.to_sym, b); x.body.arguments = a; x }
            | { line = lineno } kw("break") { AST::Break.new(lineno, nil) }
            | { line = lineno } kw("next") { AST::Next.new(lineno, nil) }
            | { line = lineno } kw("redo") { AST::Redo.new(lineno) }
            | { line = lineno } kw("retry") { AST::Retry.new(lineno) }

then = ":"
     | kw("then")
     | term - kw("then")
     | term

do = term
   | ":"
   | kw("do")

if_tail(cx) = { line = lineno } kw("elsif") - expr(cx.right):c s then - statements:s - if_tail(cx):l { condition_block(lineno, c, s, l) }
            | else_clause:e { e }
            | none { nil }

else_clause = kw("else") - statements:s { s }

for_var = mlhs
        | lhs(Cx.new)

block_var = { line = lineno } mlhs_head:l - mlhs_item:i { AST::MultipleAssignment.new(line, AST::ArrayLiteral.new(line, l + [i]), nil, nil) }
          | { line = lineno } mlhs_head:l - splat_lhs:i - "," - "&" - lhs(Cx.new):b  { x = AST::MultipleAssignment.new(line, AST::ArrayLiteral.new(line, l), nil, i); x.block = b; x }
          | { line = lineno } mlhs_head:l - "&" - lhs(Cx.new):b { x = AST::MultipleAssignment.new(line, AST::ArrayLiteral.new(l), nil, nil); x.block = b; x }
          | { line = lineno } splat_lhs:i - "&" - lhs(Cx.new):b { x = AST::MultipleAssignment.new(line, nil, nil, i); x.block = b; x }
          | { line = lineno } "&" - lhs(Cx.new):b { x = AST::MultipleAssignment.new(line, nil, nil, i); x.block = b; x }
          | { line = lineno } mlhs_head:l - splat_lhs:i { AST::MultipleAssignment.new(line, AST::ArrayLiteral.new(line, l), nil, i) }
          | { line = lineno } mlhs_head:l { AST::MultipleAssignment.new(line, AST::ArrayLiteral.new(line, l), nil, nil) }
          | { line = lineno } splat_lhs:i { AST::MultipleAssignment.new(line, nil, nil, i) }
          | { line = lineno } mlhs_item:i { i }
          | none { 0 }

splat_lhs = "*" - lhs(Cx.new):s { s }
          | "*" { true }

opt_block_var = "|" - block_var:v - "|" { v }
              | none { nil }

do_block = kw("do") - opt_block_var:v - statements:b - kw("end") { AST::Iter.new(lineno, v, b) }

block_call(cx) = block_call(cx):t dot_or_colon - { line = lineno } operation2:n paren_args:a { x = AST::SendWithArguments.new(line, t, n.to_sym, a[0]); x.block = a[1]; transform(x) }
               | block_call(cx):t dot_or_colon - { line = lineno } operation2:n { transform(AST::Send.new(line, t, n.to_sym)) }
               | command(cx):c s do_block:b { c.block = b; transform(c) }


brace_block(cx) = "{" - opt_block_var:v - statements:b - "}" { AST::Iter.new(lineno, v, b) }
                | !{ cx.no_do? } kw("do") - opt_block_var:v - statements:b - kw("end") { AST::Iter.new(lineno, v, b) }

when_clause = { line = lineno } kw("when") - when_args:a s then - statements:s { AST::When.new(line, a, s) }

case_body = when_clause:w - case_body:l { [w] + l }
          | when_clause:w { [w] }

when_args = { line = lineno } args(Cx.new):a - "," - "*" arg(Cx.new):s { AST::ArrayLiteral.new(line, a + [AST::When.new(line, s, nil)]) }
          | { line = lineno } args(Cx.new):a { AST::ArrayLiteral.new(line, a) }
          | { line = lineno } "*" arg(Cx.new):s { AST::ArrayLiteral.new(line, [AST::When.new(line, s, nil)]) }

rescue_clause = kw("rescue") s exc_list?:l s exc_var:v s then - statements:s (- rescue_clause)?:n { case s when AST::Block; s.array.unshift(v); else; s = AST::Block.new(s.line, [v, s]); end if v; AST::RescueCondition.new(lineno, l, s, n) }

#exc_list = exc_list:l s "," - arg(Cx.new):i { l + [i] }
#         | arg(Cx.new):i { [i] }

exc_list = mrhs:v { v }
         | arg(Cx.new):i { AST::ArrayLiteral.new(lineno, [i]) }

exc_var = "=>" - lhs(Cx.new):v { set_rhs(v, AST::CurrentException.new(v.line)) }
        | none { nil }

ensure_clause = kw("ensure") - statements:s { s }


literal = numeric
        | symbol:s
        | dsym:s
        | { line = lineno } char:c { AST::FixnumLiteral.new(line, c) }
char = "?" &"\\" char_escape:c { c }
     | "?" !any_whitespace <.> { text[0] }
char_escape = "\\\\" { ?\\ }
            | "\\x" </[0-9A-Fa-f]{2}/> { text.to_i(16) }
            | ("\\c" | "\\C-") char_escape:c { (c & 0x9f) }
            | ("\\c" | "\\C-") <.> { (text[0] & 0x9f) }
            | "\\M-" char_escape:c { (c | 0x80) }
            | "\\M-" <.> { (text[0] | 0x80) }
            | "\\" /[xcCM]/ { nil }
            | "\\" </[0-7]+/> { text.to_i(8) }
            | "\\" <.> { escaped_char(text) }


strings(cx) = { line = lineno } string:s { AST.str(lineno, s) }
            | { line = lineno } "%Q" nesting_string(true):s { AST.str(lineno, s) }
            | { line = lineno } "%q" nesting_string(false):s { AST.str(lineno, s) }
            | { line = lineno } "%" !"=" !any_whitespace nesting_string(true):s { AST.str(lineno, s) }
            | { line = lineno } !{ cx.strict? } "%=" qstring(["="]):s "=" { AST.str(lineno, s) }
            | "<<" <"-"?> heredoc_ref(text):r { r }

heredoc_ref(indent) = { line = lineno } "'" < /[^']+/ > "'" { heredoc(lineno, text, indent != '') }
                    | { line = lineno } "\"" < /[^"]+/ > "\"" { heredoc(lineno, text, indent != '', AST::DynamicString) }
                    | { line = lineno } "`" < /[^`]+/ > "`" { heredoc(lineno, text, indent != '', AST::DynamicExecuteString) }
                    | { line = lineno } < word > { heredoc(lineno, text, indent != '', AST::DynamicString) }

string = string:a s string1:b { a.all? {|x| String === x } ? a+b : a+[nil]+b }
       | string1

string1 = "\"" qstring(["\""]):s "\"" { s }
        | "'" lstring(["'"], true):s "'" { s }

xstring = "`" qstring(["`"]):s "`" { AST.str(lineno, s, AST::ExecuteString, AST::DynamicExecuteString) }
        | "%x" nesting_string(true):s { AST.str(lineno, s, AST::ExecuteString, AST::DynamicExecuteString) }

regexp(cx) = "/" !"=" !any_whitespace qstring(["/"]):s "/" re_flags:f { AST.str(lineno, s, AST::RegexLiteral, f =~ /o/ ? AST::DynamicOnceRegex : AST::DynamicRegex, regex_flags(f)) }
               | !{ cx.strict? } "/" qstring(["/"]):s "/" re_flags:f { AST.str(lineno, s, AST::RegexLiteral, f =~ /o/ ? AST::DynamicOnceRegex : AST::DynamicRegex, regex_flags(f)) }
               | "%r" nesting_string(true):s re_flags:f { AST.str(lineno, s, AST::RegexLiteral, f =~ /o/ ? AST::DynamicOnceRegex : AST::DynamicRegex, regex_flags(f)) }

re_flags = < /[A-Za-z]*/ > { text }

words = { line = lineno } "%w" </[^A-Za-z0-9]/> { strend = string_end(text) } word_list(false, text, strend, 0)?:w &{ w[0] == 0 } <.> &{ text == strend } { w ? AST::ArrayLiteral.new(lineno, w[1]) : AST::EmptyArray.new(lineno) }
qwords = { line = lineno } "%W" </[^A-Za-z0-9]/> { strend = string_end(text) } word_list(true, text, strend, 0)?:w &{ w[0] == 0 } <.> &{ text == strend } { w ? AST::ArrayLiteral.new(lineno, w[1]) : AST::EmptyArray.new(lineno) }

word_space = newline
           | " "
           | "\t"
           | "\v"
           | "\f"

word_part(q,lft,rgt,d) = &{ lft != rgt } word_part(q,lft,rgt,d):a word_part(q,lft,rgt,a[0]):b { [b[0], a[1] + b[1]] }
                       | &{ lft != rgt } <.> &{ text == lft } { [d + 1, [lft]] }
                       | &{ lft != rgt } <.> &{ d > 0 && text == rgt } { [d - 1, [rgt]] }
                       | !{ q } lstring(SPACES + [lft, rgt], true):i { [d, i] }
                       | &{ q } qstring(SPACES + [lft, rgt]):i { [d, i] }
word_list(q,lft,rgt,d) = { line = lineno } word_part(q,lft,rgt,d):i word_space+ word_list(q,lft,rgt,i[0]):l { [l[0], [AST.str(lineno,i[1])] + l[1]] }
                       | { line = lineno } word_part(q,lft,rgt,d):i { [i[0], [AST.str(lineno,i[1])]] }

nesting_string(q) = </[^A-Za-z0-9]/> { strend = string_end(text) } nesting_string_part(q,text,strend)?:s <.> &{ text == strend } { s || [] }
nesting_string_part(q,lft,rgt) = &{ lft != rgt } nesting_string_part(q,lft,rgt):a nesting_string_part(q,lft,rgt):b { a + b }
                               | &{ lft != rgt } <.> &{ text == lft } nesting_string_part(q,lft,rgt):i <.> &{ text == rgt } { [lft] + i + [rgt] }
                               | !{ q } lstring([lft, rgt], true):i { i }
                               | &{ q } qstring([lft, rgt]):i { i }

lstring(stops,escapes) = lstring_item(stops,escapes)*:s { s }
lstring_item(stops,escapes) = !{ stops.include?("\\") } &{ stops.include?("\n") } "\\" newline:nl { nl }
                            | !{ stops.include?("\\") } "\\" < . > &{ stops.include?(text) } { text }
                            | !{ stops.include?("\\") } "\\\\" &{ escapes } { "\\" }
                            | !{ stops.include?("\n") } newline:nl { nl }
                            | < . > !{ stops.include?(text) } { text }

qstring(stops) = qstring_item(stops)*:s { s }
qstring_item(stops) = !{ stops.include?("\\") } "\\" newline { "" }
                    | !{ stops.include?("\\") } &"\\" char_escape:c { c.chr }
                    | !{ stops.include?('#') } "#" dyn_string_part:d { case d when nil; AST::StringLiteral.new(lineno, ""); when AST::StringLiteral; d.string; when AST::ToString, AST::DynamicString; d; else; AST::ToString.new(lineno, d); end }
                    | !{ stops.include?("\n") } newline:nl { nl }
                    | < . > !{ stops.include?(text) } { text }

dyn_string_part = { line = lineno } cvar:n { AST::ClassVariableAccess.new(line, n.to_sym) }
                | { line = lineno } ivar:n { AST::InstanceVariableAccess.new(line, n.to_sym) }
                | { line = lineno } backref:n { AST::BackRef.new(line, n[1..-1].to_sym) }
                | { line = lineno } gvar:n { AST::GlobalVariableAccess.for_name(line, n.to_sym) }
                | "{" - "}" { nil }
                | "{" - statements:s - "}" { s }


symbol = { line = lineno } ":" sym:s { AST::SymbolLiteral.new(line, s.to_sym) }
sym = fname
    | cvar
    | ivar
    | gvar
    | backref

dsym = ":" string1:s { AST.str(lineno, s, AST::SymbolLiteral, AST::DynamicSymbol) do |x| x.to_sym end}
     | "%s" nesting_string(false):s { AST.str(lineno, s, AST::SymbolLiteral, AST::DynamicSymbol) do |x| x.to_sym end}

numeric = { line = lineno } float:n { AST::FloatLiteral.new(lineno, n) }
        | { line = lineno } integer:n { Fixnum === n ? AST::FixnumLiteral.new(lineno, n) : AST::NumberLiteral.new(lineno, n) }

integer = "-"?:neg "0" ("x" | "X") < /[0-9A-Fa-f]+/ ("_" /[0-9A-Fa-f]+/)* > { n = text.gsub('_','').to_i(16); (neg ? -n : n) }
        | "-"?:neg "0" ("d" | "D") < /[0-9]+/ ("_" /[0-9]+/)* > { n = text.gsub('_','').to_i(10); (neg ? -n : n) }
        | "-"?:neg "0" ("b" | "B") < /[0-1]+/ ("_" /[0-1]+/)* > { n = text.gsub('_','').to_i(2); (neg ? -n : n) }
        | "-"?:neg "0" ("o" | "O")? < /[0-7]+/ ("_" /[0-7]+/)* > { n = text.gsub('_','').to_i(8); (neg ? -n : n) }
        | "-"? "0" { 0 }
        | < /-?[1-9][0-9]*/ ("_" /[0-9]+/)* > { (text.gsub('_','').to_i(10)) }

         float = < /-?[0-9]+/ ("_" /[0-9]+/)* (/\.[0-9]+/ ("_" /[0-9]+/)* float_exponent? | float_exponent) > { text.gsub('_','').to_f }
float_exponent = /[eE][-+]?[0-9]+/ ("_" /[0-9]+/)*

variable = { line = lineno } name:n { x = AST::Send.new(line, AST::Self.new(line), n.to_sym, true, true); x.check_for_local = true; transform(x) }
         | { line = lineno } cvar:n { AST::ClassVariableAccess.new(line, n.to_sym) }
         | { line = lineno } ivar:n { AST::InstanceVariableAccess.new(line, n.to_sym) }
         | { line = lineno } gvar:n { AST::GlobalVariableAccess.for_name(line, n.to_sym) }
         | { line = lineno } nthref:n { AST::NthRef.new(line, n.to_i) }
         | { line = lineno } backref:n { AST::BackRef.new(line, n[1..-1].to_sym) }
         | { line = lineno } constant:c { AST::ConstantAccess.new(lineno, c.to_sym) }
         | { line = lineno } kw("nil") { AST::NilLiteral.new(lineno) }
         | { line = lineno } kw("self") { AST::Self.new(lineno) }
         | { line = lineno } kw("true") { AST::TrueLiteral.new(lineno) }
         | { line = lineno } kw("false") { AST::FalseLiteral.new(lineno) }
         | { line = lineno } kw("__FILE__") { AST::File.new(lineno) }
         | { line = lineno } kw("__LINE__") { AST::FixnumLiteral.new(lineno, line) }

nthref = "$" < /[1-9][0-9]*/ > { text }
backref = < "$" /[&`'+]|[1-9][0-9]*/ > { text }

superclass = s "<" - expr(Cx.new):e term { e }
           | term { nil }

f_arglist = "(" - f_args:a - ")" { a }
          | f_args:a term { a }

f_args_tail = f_optarg:o - "," - f_rest_arg:s { [o.map {|x| x.name }, o, s] }
            | f_optarg:o { [o.map {|x| x.name }, o, nil] }
            | f_rest_arg:s { [[], [], s] }
            | f_norm_arg:n - "," - f_args_tail:l { [[n] + l[0], l[1], l[2]] }
            | f_norm_arg:n { [[n], [], nil] }

f_args = { line = lineno } f_args_tail:l opt_f_block_arg:b { defs = nil; defs = AST::Block.new(line, l[1]) if l[1].size > 0; x = AST::FormalArguments.new(line, l[0], defs, l[2]); x.block_arg = b if b; x }
       | { line = lineno } f_block_arg:b { x = AST::FormalArguments.new(line, [], nil, nil); x.block_arg = b; x }
       | none { AST::FormalArguments.new(line, [], nil, nil) }

f_norm_arg = constant { error }
           | cvar { error }
           | ivar { error }
           | gvar { error }
           | name:n { n.to_sym }

constant = < /[A-Z](?:[A-Za-z0-9_]|[^\0-\177])*/ > { text }
cvar = < "@@" word > { text }
ivar = < "@" word > { text }
gvar = < "$" word > { text }
     | < "$" /[0~*$?!@;,.=:<>\/\\"]/ > { text }
     | < "$-" /[A-Za-z0-9]/ > { text }

f_opt = { line = lineno } name:n - "=" - arg(Cx.new):v { AST::LocalVariableAssignment.new(line, n.to_sym, v) }

f_optarg = f_optarg:l - "," - f_opt:a { l + [a] }
         | f_opt:a { [a] }

f_rest_arg = "*" name:n { n.to_sym }
           | "*" { true }

f_block_arg = { line = lineno } "&" name:n { AST::BlockArgument.new(line, n.to_sym) }
opt_f_block_arg = - "," - f_block_arg:b { b }
                | none { nil }

singleton = variable:v { v }
          | "(" - expr(Cx.new):e - ")" { e }

assoc_list = assocs(Cx.new):a trailer { a }
           | args(Cx.new):a trailer { a }
           | none { [] }

assocs(cx) = assocs(cx):l - "," - assoc(cx.right):x { l + x }
               | assoc(cx):x { x }

assoc(cx) = arg(cx):k - "=>" - arg(cx.right):v { [k,v] }

operation = !"defined?" fid:f { f }
          | name:i { i }
          | constant:c { c }

operation2 = fid:f { f }
           | identifier:i { i }
           | constant:c { c }
           | < opmethod > { text }

operation3 = fid:f { f }
           | identifier:i { i }
           | < opmethod > { text }

identifier = < /(?:[a-z_]|[^\0-\177])(?:[A-Za-z0-9_]|[^\0-\177])*/ > { text }
name = < (fid | identifier) > !{ RESERVED.include?(text) } { text }

word = < /(?:[A-Za-z_]|[^\0-\177])(?:[A-Za-z0-9_]|[^\0-\177])*/ > { text }

kw(w) = < word /[?!]?/ > &{ text == w } { w }

fid = < /[A-Za-z0-9_]+[!?]/ > { text }

dot_or_colon = s "."
             | "::"

newline = < ("\r" "\n"? | "\n") > @pending_heredocs rd_doc* { text }
rd_doc = "=begin" (!"=end" /[^\r\n]*(?:\r\n?|\n)/)+ "=end" /[^\r\n]*(?:\r\n?|\n)/

pending_heredocs = &{ h = pop_heredoc } @pending_heredocs heredoc(h)
                 | &{ true }
heredoc_stop(h) = < (/[^\r\n]*(?:\r\n?|\n)/ | /[^\r\n]*/ eof) > &{ h.stop?(text) }
heredoc_line(h) = &{ h.dynamic } !heredoc_stop(h) qstring(NEWLINE):items newline:nl { items + [nl] }
                | !{ h.dynamic } !heredoc_stop(h) lstring(NEWLINE, false):items newline:nl { items + [nl] }
heredoc(h) = heredoc_line(h)*:lines (heredoc_stop(h) | fail(h)) { h.append(lines); nil }

trailer = (newline | ",")?

opt_terms = terms?
term = s ";" | s newline | s eof
terms = terms s ";"
      | term

none = &{ true }

fail(s) = { raise "Parse failed: #{s.inspect}" }
dbg = &debug(nil)
debug(s) = </(\n|\r|.){0,20}/> { ls = caller.map {|x| x.sub!(::Regexp.new(".*`_(.*)'$"), '\1') }.compact; ls.shift if ls.first == 'dbg'; px = ls.first; p ls; px = px+": #{s}" if s; puts "#{px}: #{text.inspect}" }

