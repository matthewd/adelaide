%% name = Adelaide::Parser
%% {

# The big ambiguities:
#  / -- divide vs regexp
#  : -- symbol vs ternary vs "then" vs ::
#  << -- heredoc vs lshift

  attr_accessor :ast

  attr_accessor :heredocs

  def setup
    @heredocs = []
  end

  SPACES = ["\t", "\n", "\v", "\r", ' ', "\r\n"]
  NEWLINE = ["\r", "\n", "\r\n"]
  def string_end(c)
    case c
    when '('; ')'
    when '[': ']'
    when '<': '>'
    when '{': '}'
    else; c
    end
  end


  # Iron out consecutive literal string-parts, then decide whether this
  # is a dstr
  def str(parts)
    x = []
    parts.each do |part|
      if String === x.last && String === part
        x.last << part
      else
        x << part
      end
    end
    x = x.map {|part| String === part ? str_(part) : part }

    if x.size == 1 && AST::String === x.first
      x.first
    else
      dstr_(x)
    end
  end

  def escaped_char(c)
    case c
    when 't'; "\t"
    when 'v'; "\v"
    when 'n'; "\n"
    when 'r'; "\r"
    when "\n"; ""
    else; c
    end
  end

  module AST; end
  class AST::Node
  end

  class AST::HereDoc < AST::Node
    def collapse
      @value = @value.collapse
    end
    def stop?(line)
      (@indent ? line.strip : line.chomp) == @term
    end
  end
  class AST::Int < AST::Node
    def negate=(v); @negate = v; end
  end
  class AST::Float < AST::Node
    def negate=(v); @negate = v; end
  end
  class AST::LocalSend < AST::Node
    def as_command(args,block)
      @args, @block = args, block
      self
    end
  end
  class AST::ObjSend < AST::Node
    def as_command(args,block)
      @args, @block = args, block
      self
    end
  end
  class AST::ScopedConstant < AST::Node
    def as_command(args,block)
      AST::ObjSend.new(@parent, @name, args, block)
    end
  end
  class AST::DString < AST::Node
    def collapse
      x = []
      parts.each do |part|
        if ::String === x.last && ::String === part
          x.last << part
        else
          x << part
        end
      end
      x = x.map {|part| ::String === part ? AST::String.new(part) : part }

      @parts = x

      if parts.size == 1 && AST::String === parts.first
        parts.first
      else
        self
      end
    end
  end

  def heredoc(term, indent, value, dynamic)
    h = heredoc_(term, indent, value, dynamic)
    @heredocs << h
    h
  end
  def pop_heredoc
    @heredocs.pop
  end


  def command_candidate?(candidate, assignment)
    case candidate
    when AST::LocalSend, AST::ObjSend
      if candidate.args.nil? && candidate.block.nil?
        true
      elsif candidate.name == "[]" && assignment
        true
      end
    when AST::ScopedConstant
      true
    else
      false
    end
  end


  RESERVED = %w(
    __LINE__ __FILE__ BEGIN END alias and begin break case class def
    defined? do else elsif end ensure false for in module next nil not
    or redo rescue retry return self super then true undef when yield
    if unless while until
  )
}

eof = !.

#sp = /([ \t\n\v\r]+|#[^\r\n]*[\r\n]*)+/
space_element = hspace | newline | comment
comment = /#[^\r\n]*/
hspace = /[ \t\v]+/

any_whitespace = /[ \t\n\r\n]+/

wsp = space_element+
- = space_element*
sp = (hspace | comment)+
s = (hspace | comment)*

%% root = ast Root(value)

#root = { setup } primary:r - eof { @ast = r }
root = { setup } program:r - eof { @ast = root(r) }
program = statements

statements = - stmts:s opt_terms { s }

%% body = ast Body(stmts, rescue_, else_, ensure_)
block_body = statements:a (- rescue_clause)*:b - else_clause?:c - ensure_clause?:d ~body(a,b,c,d)

stmts = stmts:l terms - statement:s { l + [s] }
      | statement:s { [s] }
      | none { [] }

%% big_begin = ast BigBegin(value)
%% big_end = ast BigEnd(value)
%% undef_ = ast Undef(names)
statement = statement:v s kw("if") - expr:c ~if_([maybe(c,v)])
          | statement:v s kw("unless") - expr:c ~unless_(c,v,nil)
          | statement:v s kw("while") - expr:c ~while_(c,v)
          | statement:v s kw("until") - expr:c ~until_(c,v)
          | statement:v s kw("rescue") - statement:f ~recover(v,f)
          | alias_statement:a { a }
          | kw("undef") - undef_list:n ~undef_(n)
          | kw("BEGIN") - "{" - statements:s - "}" ~big_begin(s)
          | kw("END") - "{" - statements:s - "}" ~big_end(s)
          | lhs:l s "=" !"=" !">" !"~" - command_call:v ~assign(l,v)
          | mlhs:l s "=" !"=" !">" !"~" - command_call:v ~assign(l,v)
          | variable:l s op_asgn:o - command_call:v ~op_assign_0(l,o,v)
          | primary:l s "[" - aref_args:i - "]" - op_asgn:o - command_call:v ~op_assign_1(l,i,o,v)
          | primary:t s "." - word:n - op_asgn:o - command_call:v ~op_assign_2(l,n,o,v)
          | primary:t s "::" - name:n - op_asgn:o - command_call:v ~op_assign_2(l,n,o,v)
          | backref s op_asgn - command_call
          | lhs:l s "=" !"=" !">" !"~" - mrhs:v ~assign(l,v)
          | mlhs:l s "=" !"=" !">" !"~" - mrhs:v ~assign(l,v)
          | mlhs:l s "=" !"=" !">" !"~" - arg:v ~assign(l,v)
          | expr:e { e }

alias_statement = kw("alias") fitem fitem
                | kw("alias") gvar gvar
                | kw("alias") gvar backref # FIXME: might be a n-ref, which should error

%% logical_and = ast LogicalAnd(left, right)
%% logical_or = ast LogicalOr(left, right)
%% logical_not = ast LogicalNot(value)
expr = expr:l - kw("and") - expr2:r ~logical_and(l,r)
     | expr:l - kw("or") - expr2:r ~logical_or(l,r)
     | expr2:e { e }
expr2 = kw("not") - expr2:e ~logical_not(e)
      | "!" - expr2:e ~logical_not(e)
      | command_call:c { c }
      | arg:a { a }

%% return_ = ast Return(value)
%% break_ = ast Break(value)
%% next_ = ast Next(value)
%% yield_ = ast Yield(value)
%% super_ = ast Super(value)
%% redo_ = ast Redo()
%% retry_ = ast Retry()

%% defined_ = ast Defined(value)

command_call = block_call:t s dot_or_colon - operation2:n command_args:a ~obj_send(t,n,a,nil)
             | block_call:c { c }
             | command:c { c }
             | kw("return") - loose_call_args:v ~return_(v)
             | kw("break") - loose_call_args:v ~break_(v)
             | kw("next") - loose_call_args:v ~next_(v)


%% block = ast Block(vars, body)
cmd_brace_block = "{" - opt_block_var:v - statements:s - "}" ~block(v,s)

command = primary:t s dot_or_colon - operation2:n command_args:a s cmd_brace_block:b ~obj_send(t,n,a,b)
        | primary:t s dot_or_colon - operation2:n command_args:a ~obj_send(t,n,a,nil)
        | operation:op command_args:a (s cmd_brace_block)?:b ~local_send(op,a,b)
        | kw("super") command_args:v ~super_(v)
        | kw("yield") command_args:v ~yield_(v)
        | primary:c command_args:a &{ command_candidate?(c, false) } (s cmd_brace_block)?:b { c.as_command(a,b) }

mlhs = "(" - mlhs - ")"
     | mlhs_head - mlhs_item
     | mlhs_head - splat_lhs
     | splat_lhs

mlhs_head = mlhs_head - mlhs_item - ","
          | mlhs_item - ","

mlhs_item = "(" - mlhs - ")"
          | mlhs_node

mlhs_node = primary:t &{ command_candidate?(t, true) } ~t
          | "::" - constant:c ~toplevel_constant(c)
          | backref
          | variable

lhs = mlhs_node

cname = identifier
      | constant

cpath = "::" - cname:c ~toplevel_constant(c)
      | primary:v &{ AST::ScopedConstant === v } ~v
      | cname:c ~constant_access(c)

fname = fid
      | identifier "="?
      | constant "="?
      | < opmethod > { text }

fitem = fname
      | symbol
      | dsym

undef_list = undef_list - "," - fitem
           | fitem

opmethod = "[]="
         | "[]"
         | "<=>"
         | "==="
         | "=="
         | "=~"
         | "<<"
         | ">>"
         | ">="
         | "<="
         | ">"
         | "<"
         | "+@"
         | "-@"
         | "**"
         | "+"
         | "-"
         | "*"
         | "/"
         | "%"
         | "~"
         | "|"
         | "^"
         | "&"
         | "`"

op_asgn = < "**="
          | "*="
          | "<<="
          | ">>="
          | "&&="
          | "&="
          | "||="
          | "|="
          | "+="
          | "-="
          | "/="
          | "^="
          | "%="
          > { text[0..-2] }

%% assign = ast Assign(lhs,rhs)
%% op_assign = ast OpAssign(op,lhs,rhs)
%% plus = ast Plus(left,right)
%% minus = ast Minus(left,right)
%% mult = ast Mult(left,right)
%% div = ast Div(left,right)
%% mod = ast Modulus(left,right)
%% pow = ast Pow(left,right)
%% range = ast Range(left,right,open)

%% unary_plus = ast UnaryPlus(value)
%% unary_minus = ast UnaryMinus(value)

%% recover = ast Recover(attempt, fallback)

%% op_assign_0 = ast OpAssign0(target,op,value)
%% op_assign_1 = ast OpAssign1(target,index,op,value)
%% op_assign_2 = ast OpAssign2(target,name,op,value)

arg = arg:l s ".." !"." - arg:r ~range(l,r,true)
    | arg:l s "..." - arg:r ~range(l,r,false)
    | arg:l s "+" !"=" - arg:r ~plus(l,r)
    | arg:l s "-" !"=" - arg:r ~minus(l,r)
    | arg:l s "*" !"*" !"=" - arg:r ~mult(l,r)
    | arg:l s "/" !"=" - arg:r ~div(l,r)
    | arg:l s "%" !"=" - arg:r ~mod(l,r)
    | "-" - integer:l s "**" - arg:r
    | "-" - float:l s "**" - arg:r
    | "+" - arg:v ~unary_plus(v)
    | "-" - arg:v ~unary_minus(v)
    | arg:l s "**" !"=" - arg:r ~pow(l,r)
    | arg:l s "|" !"|" !"=" - arg:r ~bit_or(l,r)
    | arg:l s "^" !"=" - arg:r ~bit_xor(l,r)
    | arg:l s "&" !"&" !"=" - arg:r ~bir_and(l,r)
    | arg:l s "<=>" - arg:r
    | arg:l s ">" !"=" !">" - arg:r
    | arg:l s ">=" - arg:r
    | arg:l s "<" !"=" !"<" - arg:r
    | arg:l s "<=" !">" - arg:r
    | arg:l s "==" !"=" - arg:r
    | arg:l s "===" - arg:r
    | arg:l s "!=" - arg:r
    | arg:l s "=~" - arg:r
    | arg:l s "!~" - arg:r
    | "!" - arg:v ~logical_not(v)
    | "~" - arg:v ~bit_not(v)
    | arg:l s "<<" !"=" - arg:r ~lshift(l,r)
    | arg:l s ">>" !"=" - arg:r ~rshift(l,r)
    | arg:l s "&&" !"=" - arg:r ~logical_and(l,r)
    | arg:l s "||" !"=" - arg:r ~logical_or(l,r)
    | kw("defined?") - arg:v ~defined_(v)
    | arg:c s "?" - arg:t - ":" - arg:f ~ternary(c,t,f)
    | lhs:l s "=" !"=" !">" !"~" - arg:v s kw("rescue") - arg:r ~assign(l,recover(v,r))
    | lhs:l s "=" !"=" !">" !"~" - arg:v ~assign(l,v)
    | variable:l s op_asgn:o - arg:v ~op_assign_0(l,o,v)
    | primary:t s "[" - aref_args:i - "]" s op_asgn:o - arg:v ~op_assign_1(t,i,o,v)
    | primary:t s "." - word:n s op_asgn:o - arg:v ~op_assign_2(t,n,o,v)
    | (primary:t s "::" - constant:c ~scoped_constant(t,c)):c s op_asgn:o - arg:v ~constant_assignment(c,o,v)
    | primary:t s "::" - identifier:n s op_asgn:o - arg:v ~op_assign_2(t,n,o,v)
    | ("::" - constant:c ~toplevel_constant(c)):c s op_asgn:o - arg:v ~constant_assignment(c,o,v)
    | backref s op_asgn - arg
    | primary

%% hash = ast Hash(elements)
%% array = ast Array(elements)

%% ternary = ast Ternary(cond,t,f)
%% lshift = ast LShift(left,right)
%% rshift = ast RShift(left,right)
%% bit_and = ast BitAnd(left,right)
%% bit_or = ast BitOr(left,right)
%% bit_xor = ast BitXOr(left,right)
%% bit_not = ast BitNot(value)

%% splat = ast Splat(value)
%% amplify = ast Amplify(value)

aref_args = command:v (- newline)? { [v] }
          | "*" arg:s (- newline)? ~splat(s)
          | assocs:l (- ",")? { l }
          | args:l - "," - "*" arg:s (- newline)? { l + splat(s) }
          | args:l (- ",")? { l }

paren_args = "(" - ")" { [] }
           | "(" - call_args:a - newline? - ")" { a }
           | "(" - block_call:b - newline? - ")" { [b] }
           | "(" - args:a - "," - block_call:b - newline? - ")" { a + [b] }

loose_call_args = !kw("if") !kw("unless") !kw("while") !kw("until") call_args:a ~a
call_args = command:c { [c] }
          | args:a - "," - assocs:h - "," - "*" arg:s opt_block_arg:b { a + [hash(h), splat(s)] + b }
          | args:a - "," - assocs:h opt_block_arg:b { a + [hash(h)] + b }
          | args:a - "," - "*" arg:s opt_block_arg:b { a + [splat(s)] + b }
          | args:a opt_block_arg:b { a + b }
          | assocs:h - "," - "*" arg:s opt_block_arg:b { [hash(h), splat(s)] + b }
          | assocs:h opt_block_arg:b { [hash(h)] + b }
          | "*" arg:s opt_block_arg:b { [splat(s)] + b }
          | block_arg:b { [b] }


call_args2 = arg:v - "," - args:a opt_block_arg:b { [v] + a + b }
           | arg:v - "," - block_arg:b { [v,b] }
           | arg:v - "," - "*" arg:s opt_block_arg:b { [v,splat(s)] + b }
           | arg:v - "," - args:a - "," - "*" arg:s opt_block_arg:b { [v] + a + [splat(s)] + b }
           | assocs:h - "," - "*" arg:s opt_block_arg:b { [hash(h),splat(s)] + b }
           | assocs:h opt_block_arg:b { [hash(h)] + b }
           | arg:v - "," - args:a - "," - assocs:h - "," - "*" arg:s opt_block_arg:b { [v]+a+[hash(h),splat(s)] + b }
           | arg:v - "," - args:a - "," - assocs:h opt_block_arg:b { [v]+a+[hash(h)] + b }
           | arg:v - "," - assocs:h - "," - "*" arg:s opt_block_arg:b { [v,hash(h),splat(s)] + b }
           | arg:v - "," - assocs:h opt_block_arg:b { [v,hash(h)] + b }
           | "*" arg:s opt_block_arg:b { [splat(s)] + b }
           | block_arg:b { [b] }

command_args = "(" - call_args2:a - ")" { a }
             | "(" - ")" { [] }
             | sp loose_call_args:a { a }


block_arg = "&" - arg:v ~amplify(v)
opt_block_arg = - "," - block_arg:v { [v] }
              | none { [] }

args = args:l - "," - arg:v { l + [v] }
     | arg:v { [v] }

mrhs = args:l - "," - arg:v { l + [v] }
     | args:l - "," - "*" arg:v { l + [splat(v)] }
     | "*" arg:v { [splat(v)] }

%% method_ = ast Method(obj,name,args,body)
%% if_ = ast If(parts)
%% unless_ = ast Unless(cond,true_value,false_value)
%% while_ = ast While(cond,value)
%% until_ = ast Until(cond,value)
%% case_ = ast Case(value,parts)

%% toplevel_constant = ast ToplevelConstant(name)
%% scoped_constant = ast ScopedConstant(parent, name)
%% constant_access = ast ConstantAccess(name)
%% variable_access = ast VariableAccess(name)

%% statements = ast Statements(value)

%% class_ = ast Class(name, parent, body)
%% singleton_class = ast SingletonClass(value, body)
%% module_ = ast Module(name, body)

%% fid = ast Fid(s)

primary = primary:t s "::" - constant:c ~scoped_constant(t,c)
        | primary:t s "[" - aref_args:a - "]" ~obj_send(t, "[]", a, nil)
        | primary:t s dot_or_colon - operation2:n paren_args:a s brace_block:b ~obj_send(t,n,a,b)
        | primary:t s dot_or_colon - operation2:n s brace_block:b ~obj_send(t,n,nil,b)
        | primary:t s dot_or_colon - operation2:n paren_args:a ~obj_send(t,n,a,nil)
        | primary:t s dot_or_colon - operation3:n ~obj_send(t,n,nil,nil)
        | operation:n paren_args:a s brace_block:b ~local_send(n,a,b)
        | operation:n paren_args:a ~local_send(n,a,nil)
        | kw("super") paren_args:v s brace_block:b
        | kw("super") s brace_block:b
        | kw("super") paren_args:v ~super_(v)
        | kw("super") ~super_(nil)
        | operation:n s brace_block:b ~local_send(n,[],b)
        | literal
        | strings
        | xstring
        | regexp
        | words
        | qwords
        | backref
        | fid:n ~local_send(n,nil,nil)
        | variable
        | kw("begin") - block_body:b - kw("end") { b } ~statements(b)
        | "(" - expr:e - newline? - ")" { e }
        | "(" - statements:s - ")" ~statements(s)
        | "::" - constant:c ~toplevel_constant(c)
        | "[" - aref_args:a - "]" ~array(a)
        | "{" - assoc_list:l - "}" ~hash(l)
        | "[" - "]" ~array([])
        | "{" - "}" ~hash([])
        | kw("return") ~return_(nil)
        | kw("yield") s "(" - call_args:v - ")" ~yield_(v)
        | kw("yield") s "(" - ")" ~yield_(nil)
        | kw("yield") ~yield_(nil)
        | kw("defined?") - "(" - expr:v - ")" ~defined_(v)
        | kw("if") - expr:e then - statements:s - if_tail:l - kw("end") { if_([maybe(e,s)] + l) }
        | kw("unless") - expr:e then - statements:s - else_clause?:f - kw("end") ~unless_(e,s,f)
        | kw("while") - expr:e - statements:s - kw("end") ~while_(e,s)
        | kw("until") - expr:e - statements:s - kw("end") ~until_(e,s)
        | kw("case") opt_terms - case_body:b - kw("end") ~case_(nil,b)
        | kw("case") - expr:e opt_terms - case_body:b - kw("end") ~case_(e,b)
        | kw("for") - for_var - kw("in") - expr do - statements - kw("end")
        | kw("class") - cpath:n superclass:s - block_body:b - kw("end") ~class_(n,s,b)
        | kw("class") - "<<" - expr term:e - block_body:b - kw("end") ~singleton_class(e,b)
        | kw("module") - cpath:n - block_body:b - kw("end") ~module_(n,b)
        | kw("def") - fname:n s f_arglist:a - block_body:b - kw("end") ~method_(nil,n,a,b)
        | kw("def") - singleton:o s dot_or_colon - fname:n s f_arglist:a - block_body:b - kw("end") ~method_(o,n,a,b)
        | kw("break") ~break_(nil)
        | kw("next") ~next_(nil)
        | kw("redo") ~redo_()
        | kw("retry") ~retry_()

then = ":"
     | kw("then")
     | term - kw("then")
     | term

do = term
   | ":"
   | kw("do")

%% maybe = ast Maybe(cond, value)
if_tail = kw("elsif") - expr:c then - statements:s - if_tail:l { [maybe(c,s)] + l }
        | else_clause:e { [e] }
        | none { [] }

%% else_ = ast Else(value)
else_clause = kw("else") - statements:s ~else_(s)

for_var = lhs
        | mlhs

block_par = block_par:l - "," - mlhs_item:i { l + [[:lhs, i]] }
          | mlhs_item:i { [[:lhs, i]] }

block_var = block_par:l - "," - "&" - lhs:b { l + [[:block, b]] }
          | block_par:l - "," - splat_lhs:s - "," - "&" - lhs:b { l + [[:rest, s], [:block, b]] }
          | block_par:l - "," - splat_lhs:s { l + [[:rest, s]] }
          | block_par:l - "," { l }
          | block_par:l { l }
          | splat_lhs:s - "," - "&" - lhs:b { [[:rest, s], [:block, b]] }
          | splat_lhs:s { [[:rest, s]] }
          | "&" - lhs:b { [[:block, b]] }

splat_lhs = "*" - lhs:s { s }
          | "*" { nil }

opt_block_var = "|" - block_var?:v - "|" { v || [] }
              | none { [] }

do_block = kw("do") - opt_block_var:v - statements:b - kw("end") ~block(v,b)

block_call = block_call:t s dot_or_colon - operation2:n paren_args:a ~obj_send(t,n,a,nil)
           | block_call:t s dot_or_colon - operation2:n ~obj_send(t,n,[],nil)
           | command:c s do_block:b { c.block = b; c }

%% obj_send = ast ObjSend(target, name, args, block)
%% local_send = ast LocalSend(name, args, block)



brace_block = "{" - opt_block_var:v - statements:b - "}" ~block(v,b)
            | kw("do") - opt_block_var:v - statements:b - kw("end") ~block(v,b)

%% when_ = ast When(cond, value)
when_clause = kw("when") - when_args:a then - statements:s ~when_(a,s)

case_body = when_clause:w - case_body:l { [w] + l }
          | when_clause:w { [w] }
          | else_clause:e { [e] }

when_args = args:a - "," - "*" arg:s { a + [splat(s)] }
          | args:a { a + [nil] }
          | "*" arg:s { [splat(s)] }

%% rescue_ = ast Rescue(exceptions, var, value)
rescue_clause = kw("rescue") s exc_list:l s exc_var:v then - statements:s ~rescue_(l,v,s)

exc_list = mrhs:l { l }
         | arg:v { [v] }
         | none { [] }

exc_var = "=>" - lhs:v { v }
        | none { nil }

%% ensure_ = ast Ensure(value)
ensure_clause = kw("ensure") - statements:s ~ensure_(s)

%% symbol = ast Symbol(value)
%% dsymbol = ast DSymbol(value)

literal = numeric
        | symbol:s ~symbol(s)
        | dsym:s ~dsymbol(s)

%% dstr_ = ast DString(parts)
%% str_ = ast String(value)
strings = string:s ~str(s)
        | "%Q" /[^A-Za-z0-9]/:lft { strend = string_end(lft) } qstring([strend]):s .:rgt &{ rgt == strend } ~str(s)
        | "%q" /[^A-Za-z0-9]/:lft { strend = string_end(lft) } lstring([strend], ["\\"]):s .:rgt &{ rgt == strend } ~str(s)
        | "%" /[^A-Za-z0-9]/:lft { strend = string_end(lft) } qstring([strend]):s .:rgt &{ rgt == strend } ~str(s)
        | "<<" "-"?:indent heredoc_ref(indent):r { r }

heredoc_ref(indent) = "'" < /[^']+/ > "'" { heredoc(text, !!indent, dstr_([]), false) }
                    | "\"" < /[^"]+/ > "\"" { heredoc(text, !!indent, dstr_([]), true) }
                    | "`" < /[^`]+/ > "`" { heredoc(text, !!indent, xstr_(dstr_([])), true) }
                    | < word > { heredoc(text, !!indent, dstr_([]), true) }

string = < string:a string1:b > { a+b }
       | string1

string1 = "\"" qstring(["\""]):s "\"" { s }
        | "'" lstring(["'"], ["\\"]):s "'" { s }

%% xstr_ = ast XString(str)
xstring = "`" qstring(["`"]):s "`" { xstr_(str(s)) }
        | "%x" /[^A-Za-z0-9]/:lft { strend = string_end(lft) } qstring([strend]):s .:rgt &{ rgt == strend } { xstr_(str(s)) }

%% regexp = ast RegExp(value, flags)
# FIXME: The second of these options -- the one that allows the regexp
# to start with whitespace -- should only apply if we're at the start of
# an expression (inside parens, for example), and not if we're trailing.
regexp = "/" !any_whitespace qstring(["/"]):s "/" re_flags:f ~regexp(str(s),f)
       | "/" qstring(["/"]):s "/" re_flags:f ~regexp(str(s),f)
       | "%r" /[^A-Za-z0-9]/:lft { strend = string_end(lft) } qstring([strend]):s .:rgt &{ rgt == strend } re_flags:f ~regexp(str(s),f)

re_flags = < /[imux]*/ > { text }

words = "%w" /[^A-Za-z0-9]/:lft { strend = string_end(lft) } word_list(lft, strend)? .:rgt &{ rgt == strend }

word_space = newline
           | " "
           | "\t"
           | "\v"

word_list(lft,rgt) = word_list(lft,rgt) word_space+ lstring(SPACES + [rgt], [lft])

lstring_item(stops,escapes) = &{ stops.include?("\n") } "\\" newline:nl { nl }
                            | &{ escapes.include?("\n") } "\\" newline:nl { nl }
                            | "\\" < . > &{ stops.include?(text) } { text }
                            | "\\" < . > &{ escapes.include?(text) } { text }
                            | !{ stops.include?("\n") } newline:nl { nl }
                            | < . > !{ stops.include?(text) } { text }
lstring(stops,escapes) = lstring_item(stops,escapes)*:s { s }

qwords = "%W" /[^A-Za-z0-9]/:lft { strend = string_end(lft) } qword_list(lft, strend)? .:rgt &{ rgt == strend }

qword_list(lft,rgt) = qword_list(lft,rgt) word_space+ qstring(SPACES + [rgt])

qstring_item(stops) = "\\" newline { "" }
                    | "\\" < . > { escaped_char(text) }
                    | "#" !{ stops.include?('#') } dyn_string_part:d { d }
                    | !{ stops.include?("\n") } newline:nl { nl }
                    | < . > !{ stops.include?(text) } { text }
qstring(stops) = qstring_item(stops)*:s { s }

dyn_string_part = cvar:n ~variable_access(n)
                | ivar:n ~variable_access(n)
                | backref
                | gvar:n ~variable_access(n)
                | "{" - statements:s - "}" ~statements(s)


symbol = ":" sym:s { s }
sym = fname
    | cvar
    | ivar
    | gvar

dsym = ":" string1:s { str(s) }
     | "%s" /[^A-Za-z0-9]/:lft { strend = string_end(lft) } lstring([strend]):s .:rgt &{ rgt == strend } { str(s) }

numeric = float:n { n }
        | integer:n { n }
        | "-" - float:n { n.negate = true; n }
        | "-" - integer:n { n.negate = true; n }

%% integer = ast Int(value, negate)
integer = "0" ("x" | "X") < /[0-9A-Fa-f]+/ ("_" < /[0-9A-Fa-f]+/ >)* > { integer(text.to_i(16), false) }
        | "0" ("d" | "D") < /[0-9]+/ ("_" < /[0-9]+/ >)* > { integer(text.to_i(10), false) }
        | "0" ("b" | "B") < /[0-1]+/ ("_" < /[0-1]+/ >)* > { integer(text.to_i(8), false) }
        | "0" ("o" | "O")? < /[0-7]+/ ("_" < /[0-7]+/ >)* > { integer(text.to_i(2), false) }
        | "0" { integer(0, false) }
        | < /[1-9][0-9]*/ ("_" < /[0-9]+/ >)* > { integer(text.to_i(10), false) }

%% float = ast Float(value, negate)
# TODO: underscores
         float = < /[0-9]+/ (/\.[0-9]*/ float_exponent? | float_exponent) > { float(text.to_f, false) }
float_exponent = /[eE][-+]?[0-9]+/

%% nil_ = ast Nil()
%% self_ = ast Self()
%% true_ = ast True()
%% false_ = ast False()
%% file = ast File()
%% line = ast Line()
variable = name:n ~variable_access(n)
         | cvar:n ~variable_access(n)
         | ivar:n ~variable_access(n)
         | gvar:n ~variable_access(n)
         | constant:c ~constant_access(c)
         | kw("nil") ~nil_()
         | kw("self") ~self_()
         | kw("true") ~true_()
         | kw("false") ~false_()
         | kw("__FILE__") ~file()
         | kw("__LINE__") ~line()

backref = "$" /[&`'+]|[1-9][0-9]+/

superclass = s "<" - expr:e term { e }
           | term { nil }

f_arglist = "(" - f_args:a - opt_nl - ")" { a }
          | f_args:a term { a }

f_args_tail = f_optarg:o - "," - f_rest_arg:s opt_f_block_arg:b { o + s + b }
            | f_optarg:o - opt_f_block_arg:b { o + b }
            | f_rest_arg:s - opt_f_block_arg:b { s + b }
            | f_norm_arg:n - "," - f_args_tail:l { [[:req, n]] + l }
            | f_norm_arg:n opt_f_block_arg:b { [[:req, n]] + b }

f_args = f_args_tail:l { l }
       | f_block_arg:b { [b] }
       | none { [] }
#f_args = f_arg:a - "," - f_optarg:o - "," - f_rest_arg:s opt_f_block_arg:b { a + o + s + b }
#       | f_arg:a - "," - f_optarg:o opt_f_block_arg:b { a + o + b }
#       | f_arg:a - "," - f_rest_arg:s opt_f_block_arg:b { a + s + b }
#       | f_arg:a opt_f_block_arg:b { a + b }
#       | f_optarg:o - "," - f_rest_arg:s opt_f_block_arg:b { o + s + b }
#       | f_optarg:o opt_f_block_arg:b { o + b }
#       | f_rest_arg:s opt_f_block_arg:b { s + b }
#       | f_block_arg:b { [b] }
#       | none { [] }

f_norm_arg = constant { error }
           | cvar { error }
           | ivar { error }
           | gvar { error }
           | name

constant = < /[A-Z][A-Za-z0-9_]*/ > { text }
cvar = < "@@" word > { text }
ivar = < "@" word > { text }
gvar = < "$" word > { text }
     | < "$" /[~*$?!@;,.=:<>\/\\"]/ > { text }
     | < "$-" /[A-Za-z0-9]/ > { text }

#f_arg = f_arg:l - "," - f_norm_arg:n { l << [:req, n] }
#      | f_norm_arg:n { [[:req, n]] }


f_opt = name:n - "=" - arg:v { [:opt, n, v] }

f_optarg = f_optarg:l - "," - f_opt:a { l + [a] }
         | f_opt:a { [a] }

f_rest_arg = "*" name:n { [:rest, n] }
           | "*" { [:rest] }

f_block_arg = "&" name:n { [:block, n] }
opt_f_block_arg = - "," - f_block_arg:b { [b] }
                | none { [] }

singleton = variable:v { v }
          | "(" - expr:e - opt_nl - ")" { e }

assoc_list = assocs:a trailer { a }
           | args:a trailer { a }
           | none { [] }

assocs = assocs:l - "," - assoc:x { l + x }
       | assoc:x { x }

assoc = arg:k - "=>" - arg:v { [k,v] }

operation = fid:f { f }
          | name:i { i }
          | constant:c { c }

operation2 = fid:f { f }
           | identifier:i { i }
           | constant:c { c }
           | < opmethod > { text }

operation3 = fid:f { f }
           | identifier:i { i }
           | < opmethod > { text }

identifier = < /[a-z_][A-Za-z0-9_]*/ > { text }
name = < identifier > !{ RESERVED.include?(text) } { text }

word = < /[A-Za-z_][A-Za-z0-9_]*/ > { text }

kw(w) = < word /[?!]?/ > &{ text == w } { w }

fid = < /[A-Za-z0-9_]+[!?]/ > { text }

dot_or_colon = "." | "::"

opt_nl = newline?

%% heredoc_ = ast HereDoc(term, indent, value, dynamic)

newline = < ("\r" "\n"? | "\n") > @pending_heredocs { text }

pending_heredocs = &{ h = pop_heredoc } @pending_heredocs heredoc(h)
                 | &{ true }
heredoc_stop(h) = < /[^\r\n]*(?:\r\n?|\n)/ > &{ h.stop?(text) }
heredoc_line(h) = &{ h.dynamic } !heredoc_stop(h) qstring(NEWLINE):items newline:nl { items + [nl] }
                | !{ h.dynamic } !heredoc_stop(h) lstring(NEWLINE, []):items newline:nl { items + [nl] }
heredoc(h) = heredoc_line(h)*:lines heredoc_stop(h) { lines.each do |l| l.each do |atom| h.value.parts << atom end end; h.collapse; nil }

trailer = (newline | ",")?

opt_terms = terms?
term = s ";" | s newline
terms = terms s ";"
      | term

none = &{ true }

