%% name = Adelaide::Parser
%% {

# The big ambiguities:
#  / -- divide vs regexp
#  : -- symbol vs ternary vs "then" vs ::
#  << -- heredoc vs lshift

  attr_accessor :ast

  attr_accessor :heredocs

  def setup
    @heredocs = []
  end

  SPACES = ["\t", "\n", "\v", "\r", ' ', "\r\n"]
  NEWLINE = ["\r", "\n", "\r\n"]
  def string_end(c)
    case c
    when '('; ')'
    when '[': ']'
    when '<': '>'
    when '{': '}'
    else; c
    end
  end


  # Iron out consecutive literal string-parts, then decide whether this
  # is a dstr
  def str(parts)
    x = []
    parts.each do |part|
      if String === x.last && String === part
        x.last << part
      else
        x << part
      end
    end
    x = x.map {|part| String === part ? str_(part) : part }

    if x.size == 1 && AST::String === x.first
      x.first
    else
      dstr_(x)
    end
  end

  def escaped_char(c)
    case c
    when 't'; "\t"
    when 'v'; "\v"
    when 'n'; "\n"
    when 'r'; "\r"
    when "\n"; ""
    else; c
    end
  end

  module AST; end
  class AST::Node
  end

  class AST::HereDoc < AST::Node
    def collapse
      @value = @value.collapse
    end
    def stop?(line)
      (@indent ? line.strip : line.chomp) == @term
    end
  end
  class AST::Int < AST::Node
    def negate=(v); @negate = v; end
  end
  class AST::Float < AST::Node
    def negate=(v); @negate = v; end
  end
  class AST::LocalSend < AST::Node
    def as_command(args,block)
      @args, @block = args, block
      self
    end
  end
  class AST::ObjSend < AST::Node
    def as_command(args,block)
      @args, @block = args, block
      self
    end
  end
  class AST::ScopedConstant < AST::Node
    def as_command(args,block)
      AST::ObjSend.new(@parent, @name, args, block)
    end
  end
  class AST::DString < AST::Node
    def collapse
      x = []
      parts.each do |part|
        if ::String === x.last && ::String === part
          x.last << part
        else
          x << part
        end
      end
      x = x.map {|part| ::String === part ? AST::String.new(part) : part }

      @parts = x

      if parts.size == 1 && AST::String === parts.first
        parts.first
      else
        self
      end
    end
  end

  def heredoc(term, indent, value, dynamic)
    h = heredoc_(term, indent, value, dynamic)
    @heredocs << h
    h
  end
  def pop_heredoc
    @heredocs.pop
  end


  def command_candidate?(candidate, assignment)
    case candidate
    when AST::LocalSend, AST::ObjSend
      if candidate.args.nil? && candidate.block.nil?
        true
      elsif candidate.name == "[]" && assignment
        true
      end
    when AST::ScopedConstant
      true
    else
      false
    end
  end


  RESERVED = %w(
    __LINE__ __FILE__ BEGIN END alias and begin break case class def
    defined? do else elsif end ensure false for in module next nil not
    or redo rescue retry return self super then true undef when yield
    if unless while until
  )
}

eof = !.

#sp = /([ \t\n\v\r]+|#[^\r\n]*[\r\n]*)+/
space_element = hspace | newline | comment
comment = /#[^\r\n]*/
hspace = /[ \t\v]+/

any_whitespace = /[ \t\n\r\n]+/

wsp = space_element+
- = space_element*
sp = (hspace | comment)+
s = (hspace | comment)*

%% root = ast Root(value)

#root = { setup } primary:r - eof { @ast = r }
root = { setup } program:r - eof { @ast = root(r) }
program = statements

statements = - stmts:s opt_terms { s }

%% body = ast Body(stmts, rescue_, else_, ensure_)
block_body = statements:a (- rescue_clause)*:b - else_clause?:c - ensure_clause?:d ~body(a,b,c,d)

stmts = stmts:l terms - statement:s { l + [s] }
      | statement:s { [s] }
      | none { [] }

%% big_begin = ast BigBegin(value)
%% big_end = ast BigEnd(value)
%% undef_ = ast Undef(names)
statement = statement:v s kw("if") - expr(false):c ~if_([maybe(c,v)])
          | statement:v s kw("unless") - expr(false):c ~unless_(c,v,nil)
          | statement:v s kw("while") - expr(false):c ~while_(c,v)
          | statement:v s kw("until") - expr(false):c ~until_(c,v)
          | statement:v s kw("rescue") - statement:f ~recover(v,f)
          | alias_statement:a { a }
          | kw("undef") - undef_list:n ~undef_(n)
          | kw("BEGIN") - "{" - statements:s - "}" ~big_begin(s)
          | kw("END") - "{" - statements:s - "}" ~big_end(s)
          | lhs:l s "=" !"=" !">" !"~" - mrhs:v ~assign(l,v)
          | mlhs:l s "=" !"=" !">" !"~" - mrhs:v { p l } ~assign(l,v)
          | lhs:l s "=" !"=" !">" !"~" - command_call(false):v ~assign(l,v)
          | mlhs:l s "=" !"=" !">" !"~" - command_call(false):v { p l } ~assign(l,v)
          | mlhs:l s "=" !"=" !">" !"~" - arg(false):v { p l } ~assign(l,v)
          | variable:l s op_asgn:o - command_call(false):v ~op_assign_0(l,o,v)
          | primary(false):l s "[" - aref_args:i - "]" - op_asgn:o - command_call(false):v ~op_assign_1(l,i,o,v)
          | primary(false):t s "." - word:n - op_asgn:o - command_call(false):v ~op_assign_2(l,n,o,v)
          | primary(false):t s "::" - name:n - op_asgn:o - command_call(false):v ~op_assign_2(l,n,o,v)
          | backref s op_asgn - command_call(false)
          | expr(false):e { e }

%% alias_ = ast Alias(from, to)
alias_statement = kw("alias") fitem:a fitem:b ~alias_(a,b)
                | kw("alias") gvar:a gvar:b ~alias_(a,b)
                | kw("alias") gvar:a backref:b ~alias_(a,b) # FIXME: might be a n-ref, which should error

%% logical_and = ast LogicalAnd(left, right)
%% logical_or = ast LogicalOr(left, right)
%% logical_not = ast LogicalNot(value)
expr(strict) = expr(strict):l - kw("and") - expr2(false):r ~logical_and(l,r)
             | expr(strict):l - kw("or") - expr2(false):r ~logical_or(l,r)
             | expr2(strict):e { e }
expr2(strict) = kw("not") - expr2(false):e ~logical_not(e)
              | "!" - expr2(false):e ~logical_not(e)
              | command_call(strict):c { c }
              | arg(strict):a { a }

%% return_ = ast Return(value)
%% break_ = ast Break(value)
%% next_ = ast Next(value)
%% yield_ = ast Yield(value)
%% super_ = ast Super(value)
%% redo_ = ast Redo()
%% retry_ = ast Retry()

%% defined_ = ast Defined(value)

command_call(strict) = block_call(strict):t s dot_or_colon - operation2:n command_args:a ~obj_send(t,n,a,nil)
                     | block_call(strict):c { c }
                     | command(strict):c { c }
                     | kw("return") - loose_call_args:v ~return_(v)
                     | kw("break") - loose_call_args:v ~break_(v)
                     | kw("next") - loose_call_args:v ~next_(v)


%% block = ast Block(vars, body)
cmd_brace_block = "{" - opt_block_var:v - statements:s - "}" ~block(v,s)

command(strict) = primary(strict):t s dot_or_colon - operation2:n command_args:a s cmd_brace_block:b ~obj_send(t,n,a,b)
                | primary(strict):t s dot_or_colon - operation2:n command_args:a ~obj_send(t,n,a,nil)
                | operation:op command_args:a (s cmd_brace_block)?:b ~local_send(op,a,b)
                | kw("super") command_args:v ~super_(v)
                | kw("yield") command_args:v ~yield_(v)
                | primary(strict):c command_args:a &{ command_candidate?(c, false) } (s cmd_brace_block)?:b { c.as_command(a,b) }

mlhs = "(" - mlhs:i - ")" { [i] }
     | mlhs_head:l - mlhs_item:i { l + [i] }
     | mlhs_head:l - splat_lhs:i { l + [splat i] }
     | splat_lhs:i { [splat i] }

mlhs_head = mlhs_head:l - mlhs_item:i - "," { l + [i] }
          | mlhs_item:i - "," { [i] }

mlhs_item = "(" - mlhs:i - ")" { i }
          | mlhs_node:i { i }

mlhs_node = primary(false):t &{ command_candidate?(t, true) } ~t
          | "::" - constant:c ~toplevel_constant(c)
          | backref
          | variable

lhs = mlhs_node

cname = identifier
      | constant

cpath = "::" - cname:c ~toplevel_constant(c)
      | primary(false):v &{ AST::ScopedConstant === v } ~v
      | cname:c ~constant_access(c)

fname = fid
      | identifier "="?
      | constant "="?
      | < opmethod > { text }

fitem = fname
      | symbol
      | dsym

undef_list = undef_list - "," - fitem
           | fitem

opmethod = "[]="
         | "[]"
         | "<=>"
         | "==="
         | "=="
         | "=~"
         | "<<"
         | ">>"
         | ">="
         | "<="
         | ">"
         | "<"
         | "+@"
         | "-@"
         | "**"
         | "+"
         | "-"
         | "*"
         | "/"
         | "%"
         | "~"
         | "|"
         | "^"
         | "&"
         | "`"

op_asgn = < "**="
          | "*="
          | "<<="
          | ">>="
          | "&&="
          | "&="
          | "||="
          | "|="
          | "+="
          | "-="
          | "/="
          | "^="
          | "%="
          > { text[0..-2] }

%% assign = ast Assign(lhs,rhs)
%% op_assign = ast OpAssign(op,lhs,rhs)
%% plus = ast Plus(left,right)
%% minus = ast Minus(left,right)
%% mult = ast Mult(left,right)
%% div = ast Div(left,right)
%% mod = ast Modulus(left,right)
%% pow = ast Pow(left,right)
%% range = ast Range(left,right,open)

%% unary_plus = ast UnaryPlus(value)
%% unary_minus = ast UnaryMinus(value)

%% recover = ast Recover(attempt, fallback)

%% op_assign_0 = ast OpAssign0(target,op,value)
%% op_assign_1 = ast OpAssign1(target,index,op,value)
%% op_assign_2 = ast OpAssign2(target,name,op,value)

arg(strict) = arg(strict):l s ".." !"." - arg(false):r ~range(l,r,true)
            | arg(strict):l s "..." - arg(false):r ~range(l,r,false)
            | arg(strict):l s "+" !"=" - arg(false):r ~plus(l,r)
            | arg(strict):l s "-" !"=" - arg(false):r ~minus(l,r)
            | arg(strict):l s "*" !"*" !"=" - arg(false):r ~mult(l,r)
            | arg(strict):l s "/" !"=" - arg(false):r ~div(l,r)
            | arg(strict):l s "%" !"=" - arg(false):r ~mod(l,r)
            | "-" - integer:l s "**" - arg(false):r
            | "-" - float:l s "**" - arg(false):r
            | "+" - arg(false):v ~unary_plus(v)
            | "-" - arg(false):v ~unary_minus(v)
            | arg(strict):l s "**" !"=" - arg(false):r ~pow(l,r)
            | arg(strict):l s "|" !"|" !"=" - arg(false):r ~bit_or(l,r)
            | arg(strict):l s "^" !"=" - arg(false):r ~bit_xor(l,r)
            | arg(strict):l s "&" !"&" !"=" - arg(false):r ~bir_and(l,r)
            | arg(strict):l s "<=>" - arg(false):r
            | arg(strict):l s ">" !"=" !">" - arg(false):r
            | arg(strict):l s ">=" - arg(false):r
            | arg(strict):l s "<" !"=" !"<" - arg(false):r
            | arg(strict):l s "<=" !">" - arg(false):r
            | arg(strict):l s "==" !"=" - arg(false):r
            | arg(strict):l s "===" - arg(false):r
            | arg(strict):l s "!=" - arg(false):r
            | arg(strict):l s "=~" - arg(false):r
            | arg(strict):l s "!~" - arg(false):r
            | "!" - arg(false):v ~logical_not(v)
            | "~" - arg(false):v ~bit_not(v)
            | arg(strict):l s "<<" !"=" - arg(false):r ~lshift(l,r)
            | arg(strict):l s ">>" !"=" - arg(false):r ~rshift(l,r)
            | arg(strict):l s "&&" !"=" - arg(false):r ~logical_and(l,r)
            | arg(strict):l s "||" !"=" - arg(false):r ~logical_or(l,r)
            | kw("defined?") - arg(false):v ~defined_(v)
            | arg(strict):c s "?" - arg(false):t - ":" - arg(false):f ~ternary(c,t,f)
            | lhs:l s "=" !"=" !">" !"~" - arg(false):v s kw("rescue") - arg(false):r ~assign(l,recover(v,r))
            | lhs:l s "=" !"=" !">" !"~" - arg(false):v ~assign(l,v)
            | variable:l s op_asgn:o - arg(false):v ~op_assign_0(l,o,v)
            | primary(strict):t s "[" - aref_args:i - "]" s op_asgn:o - arg(false):v ~op_assign_1(t,i,o,v)
            | primary(strict):t s "." - word:n s op_asgn:o - arg(false):v ~op_assign_2(t,n,o,v)
            | (primary(strict):t s "::" - constant:c ~scoped_constant(t,c)):c s op_asgn:o - arg(false):v ~constant_assignment(c,o,v)
            | primary(strict):t s "::" - identifier:n s op_asgn:o - arg(false):v ~op_assign_2(t,n,o,v)
            | ("::" - constant:c ~toplevel_constant(c)):c s op_asgn:o - arg(false):v ~constant_assignment(c,o,v)
            | backref s op_asgn - arg(false)
            | primary(strict)

%% hash = ast Hash(elements)
%% array = ast Array(elements)

%% ternary = ast Ternary(cond,t,f)
%% lshift = ast LShift(left,right)
%% rshift = ast RShift(left,right)
%% bit_and = ast BitAnd(left,right)
%% bit_or = ast BitOr(left,right)
%% bit_xor = ast BitXOr(left,right)
%% bit_not = ast BitNot(value)

%% splat = ast Splat(value)
%% amplify = ast Amplify(value)

aref_args = command(false):v (- newline)? { [v] }
          | "*" arg(false):s (- newline)? ~splat(s)
          | assocs(false):l (- ",")? { l }
          | args(false):l - "," - "*" arg(false):s (- newline)? { l + splat(s) }
          | args(false):l (- ",")? { l }

paren_args = "(" - ")" { [] }
           | "(" - call_args(false):a - newline? - ")" { a }
           | "(" - block_call(false):b - newline? - ")" { [b] }
           | "(" - args(false):a - "," - block_call(false):b - newline? - ")" { a + [b] }

loose_call_args = !kw("if") !kw("unless") !kw("while") !kw("until") call_args(true):a ~a
call_args(strict) = command(strict):c { [c] }
                  | args(strict):a - "," - assocs(false):h - "," - "*" arg(false):s opt_block_arg:b { a + [hash(h), splat(s)] + b }
                  | args(strict):a - "," - assocs(false):h opt_block_arg:b { a + [hash(h)] + b }
                  | args(strict):a - "," - "*" arg(false):s opt_block_arg:b { a + [splat(s)] + b }
                  | args(strict):a opt_block_arg:b { a + b }
                  | assocs(strict):h - "," - "*" arg(false):s opt_block_arg:b { [hash(h), splat(s)] + b }
                  | assocs(strict):h opt_block_arg:b { [hash(h)] + b }
                  | "*" arg(false):s opt_block_arg:b { [splat(s)] + b }
                  | block_arg:b { [b] }


call_args2 = arg(false):v - "," - args(false):a opt_block_arg:b { [v] + a + b }
           | arg(false):v - "," - block_arg:b { [v,b] }
           | arg(false):v - "," - "*" arg(false):s opt_block_arg:b { [v,splat(s)] + b }
           | arg(false):v - "," - args(false):a - "," - "*" arg(false):s opt_block_arg:b { [v] + a + [splat(s)] + b }
           | assocs(false):h - "," - "*" arg(false):s opt_block_arg:b { [hash(h),splat(s)] + b }
           | assocs(false):h opt_block_arg:b { [hash(h)] + b }
           | arg(false):v - "," - args(false):a - "," - assocs(false):h - "," - "*" arg(false):s opt_block_arg:b { [v]+a+[hash(h),splat(s)] + b }
           | arg(false):v - "," - args(false):a - "," - assocs(false):h opt_block_arg:b { [v]+a+[hash(h)] + b }
           | arg(false):v - "," - assocs(false):h - "," - "*" arg(false):s opt_block_arg:b { [v,hash(h),splat(s)] + b }
           | arg(false):v - "," - assocs(false):h opt_block_arg:b { [v,hash(h)] + b }
           | "*" arg(false):s opt_block_arg:b { [splat(s)] + b }
           | block_arg:b { [b] }

command_args = "(" - call_args2:a - ")" { a }
             | "(" - ")" { [] }
             | sp loose_call_args:a { a }


block_arg = "&" - arg(false):v ~amplify(v)
opt_block_arg = - "," - block_arg:v { [v] }
              | none { [] }

args(strict) = args(strict):l - "," - arg(false):v { l + [v] }
             | arg(strict):v { [v] }

mrhs = args(false):l &{ l.size > 1 } { l }
     | args(false):l s "," - "*" arg(false):v { l + [splat(v)] }
     | "*" arg(false):v { [splat(v)] }

%% method_ = ast Method(obj,name,args,body)
%% if_ = ast If(parts)
%% unless_ = ast Unless(cond,true_value,false_value)
%% while_ = ast While(cond,value)
%% until_ = ast Until(cond,value)
%% case_ = ast Case(value,parts)

%% toplevel_constant = ast ToplevelConstant(name)
%% scoped_constant = ast ScopedConstant(parent, name)
%% constant_access = ast ConstantAccess(name)
%% variable_access = ast VariableAccess(name)

%% statements = ast Statements(value)

%% class_ = ast Class(name, parent, body)
%% singleton_class = ast SingletonClass(value, body)
%% module_ = ast Module(name, body)

%% fid = ast Fid(s)

primary(strict) = primary(strict):t s "::" - constant:c ~scoped_constant(t,c)
                | primary(strict):t s "[" - aref_args:a - "]" ~obj_send(t, "[]", a, nil)
                | primary(strict):t s dot_or_colon - operation2:n paren_args:a s brace_block:b ~obj_send(t,n,a,b)
                | primary(strict):t s dot_or_colon - operation2:n s brace_block:b ~obj_send(t,n,nil,b)
                | primary(strict):t s dot_or_colon - operation2:n paren_args:a ~obj_send(t,n,a,nil)
                | primary(strict):t s dot_or_colon - operation3:n ~obj_send(t,n,nil,nil)
                | operation:n paren_args:a s brace_block:b ~local_send(n,a,b)
                | operation:n paren_args:a ~local_send(n,a,nil)
                | kw("super") paren_args:v s brace_block:b
                | kw("super") s brace_block:b
                | kw("super") paren_args:v ~super_(v)
                | kw("super") ~super_(nil)
                | operation:n s brace_block:b ~local_send(n,[],b)
                | literal
                | strings(strict)
                | xstring
                | regexp(strict)
                | words
                | qwords
                | backref
                | fid:n ~local_send(n,nil,nil)
                | variable
                | kw("begin") - block_body:b - kw("end") { b } ~statements(b)
                | "(" - expr(false):e - newline? - ")" { e }
                | "(" - statements:s - ")" ~statements(s)
                | "::" - constant:c ~toplevel_constant(c)
                | "[" - aref_args:a - "]" ~array(a)
                | "{" - assoc_list:l - "}" ~hash(l)
                | "[" - "]" ~array([])
                | "{" - "}" ~hash([])
                | kw("return") ~return_(nil)
                | kw("yield") s "(" - call_args:v - ")" ~yield_(v)
                | kw("yield") s "(" - ")" ~yield_(nil)
                | kw("yield") ~yield_(nil)
                | kw("defined?") - "(" - expr(false):v - ")" ~defined_(v)
                | kw("if") - expr(false):e then - statements:s - if_tail:l - kw("end") { if_([maybe(e,s)] + l) }
                | kw("unless") - expr(false):e then - statements:s - else_clause?:f - kw("end") ~unless_(e,s,f)
                | kw("while") - expr(false):e - statements:s - kw("end") ~while_(e,s)
                | kw("until") - expr(false):e - statements:s - kw("end") ~until_(e,s)
                | kw("case") opt_terms - case_body:b - kw("end") ~case_(nil,b)
                | kw("case") - expr(false):e opt_terms - case_body:b - kw("end") ~case_(e,b)
                | kw("for") - for_var - kw("in") - expr(false) do - statements - kw("end")
                | kw("class") - cpath:n superclass:s - block_body:b - kw("end") ~class_(n,s,b)
                | kw("class") - "<<" - expr(false) term:e - block_body:b - kw("end") ~singleton_class(e,b)
                | kw("module") - cpath:n - block_body:b - kw("end") ~module_(n,b)
                | kw("def") - fname:n s f_arglist:a - block_body:b - kw("end") ~method_(nil,n,a,b)
                | kw("def") - singleton:o s dot_or_colon - fname:n s f_arglist:a - block_body:b - kw("end") ~method_(o,n,a,b)
                | kw("break") ~break_(nil)
                | kw("next") ~next_(nil)
                | kw("redo") ~redo_()
                | kw("retry") ~retry_()

then = ":"
     | kw("then")
     | term - kw("then")
     | term

do = term
   | ":"
   | kw("do")

%% maybe = ast Maybe(cond, value)
if_tail = kw("elsif") - expr(false):c then - statements:s - if_tail:l { [maybe(c,s)] + l }
        | else_clause:e { [e] }
        | none { [] }

%% else_ = ast Else(value)
else_clause = kw("else") - statements:s ~else_(s)

for_var = lhs
        | mlhs

block_par = block_par:l - "," - mlhs_item:i { l + [[:lhs, i]] }
          | mlhs_item:i { [[:lhs, i]] }

block_var = block_par:l - "," - "&" - lhs:b { l + [[:block, b]] }
          | block_par:l - "," - splat_lhs:s - "," - "&" - lhs:b { l + [[:rest, s], [:block, b]] }
          | block_par:l - "," - splat_lhs:s { l + [[:rest, s]] }
          | block_par:l - "," { l }
          | block_par:l { l }
          | splat_lhs:s - "," - "&" - lhs:b { [[:rest, s], [:block, b]] }
          | splat_lhs:s { [[:rest, s]] }
          | "&" - lhs:b { [[:block, b]] }

splat_lhs = "*" - lhs:s { s }
          | "*" { nil }

opt_block_var = "|" - block_var?:v - "|" { v || [] }
              | none { [] }

do_block = kw("do") - opt_block_var:v - statements:b - kw("end") ~block(v,b)

block_call(strict) = block_call(strict):t s dot_or_colon - operation2:n paren_args:a ~obj_send(t,n,a,nil)
                   | block_call(strict):t s dot_or_colon - operation2:n ~obj_send(t,n,[],nil)
                   | command(strict):c s do_block:b { c.block = b; c }

%% obj_send = ast ObjSend(target, name, args, block)
%% local_send = ast LocalSend(name, args, block)



brace_block = "{" - opt_block_var:v - statements:b - "}" ~block(v,b)
            | kw("do") - opt_block_var:v - statements:b - kw("end") ~block(v,b)

%% when_ = ast When(cond, value)
when_clause = kw("when") - when_args:a then - statements:s ~when_(a,s)

case_body = when_clause:w - case_body:l { [w] + l }
          | when_clause:w { [w] }
          | else_clause:e { [e] }

when_args = args(false):a - "," - "*" arg(false):s { a + [splat(s)] }
          | args(false):a { a + [nil] }
          | "*" arg(false):s { [splat(s)] }

%% rescue_ = ast Rescue(exceptions, var, value)
rescue_clause = kw("rescue") s exc_list:l s exc_var:v then - statements:s ~rescue_(l,v,s)

exc_list = mrhs:l { l }
         | arg(false):v { [v] }
         | none { [] }

exc_var = "=>" - lhs:v { v }
        | none { nil }

%% ensure_ = ast Ensure(value)
ensure_clause = kw("ensure") - statements:s ~ensure_(s)

%% symbol = ast Symbol(value)
%% dsymbol = ast DSymbol(value)

literal = numeric
        | symbol:s ~symbol(s)
        | dsym:s ~dsymbol(s)

%% dstr_ = ast DString(parts)
%% str_ = ast String(value)

strings(strict) = string:s ~str(s)
                | "%Q" </[^A-Za-z0-9]/> { strend = string_end(text) } qstring([strend]):s <.> &{ text == strend } ~str(s)
                | "%q" </[^A-Za-z0-9]/> { p text; strend = string_end(text) } lstring([strend], ["\\"]):s <.> &{ p s; p text; text == strend } ~str(s)
                | "%" </[^A-Za-z0-9]/> { strend = string_end(text) } qstring([strend]):s <.> &{ text == strend } ~str(s)
                | "<<" "-"?:indent heredoc_ref(indent):r { r }

heredoc_ref(indent) = "'" < /[^']+/ > "'" { heredoc(text, !!indent, dstr_([]), false) }
                    | "\"" < /[^"]+/ > "\"" { heredoc(text, !!indent, dstr_([]), true) }
                    | "`" < /[^`]+/ > "`" { heredoc(text, !!indent, xstr_(dstr_([])), true) }
                    | < word > { heredoc(text, !!indent, dstr_([]), true) }

string = < string:a string1:b > { a+b }
       | string1

string1 = "\"" qstring(["\""]):s "\"" { s }
        | "'" lstring(["'"], ["\\"]):s "'" { s }

%% xstr_ = ast XString(str)
xstring = "`" qstring(["`"]):s "`" { xstr_(str(s)) }
        | "%x" </[^A-Za-z0-9]/> { strend = string_end(text) } qstring([strend]):s <.> &{ text == strend } { xstr_(str(s)) }

%% regexp = ast RegExp(value, flags)
regexp(strict) = "/" !any_whitespace qstring(["/"]):s "/" re_flags:f ~regexp(str(s),f)
               | !{ strict } "/" qstring(["/"]):s "/" re_flags:f ~regexp(str(s),f)
               | "%r" </[^A-Za-z0-9]/> { strend = string_end(text) } qstring([strend]):s <.> &{ text == strend } re_flags:f ~regexp(str(s),f)

re_flags = < /[imux]*/ > { text }

words = "%w" </[^A-Za-z0-9]/> { p text; strend = string_end(text) } word_list(text, strend)? <.> &{ text == strend }

word_space = newline
           | " "
           | "\t"
           | "\v"

word_list(lft,rgt) = lstring(SPACES + [rgt], [lft]):i word_space+ word_list(lft,rgt):l { [str(i)] + l }
                   | lstring(SPACES + [rgt], [lft]):i { [str(i)] }

lstring_item(stops,escapes) = &{ stops.include?("\n") } "\\" newline:nl { nl }
                            | &{ escapes.include?("\n") } "\\" newline:nl { nl }
                            | "\\" < . > &{ stops.include?(text) } { text }
                            | "\\" < . > &{ escapes.include?(text) } { text }
                            | !{ stops.include?("\n") } newline:nl { nl }
                            | < . > !{ stops.include?(text) } { text }
lstring(stops,escapes) = lstring_item(stops,escapes)*:s { s }

qwords = "%W" </[^A-Za-z0-9]/> { strend = string_end(text) } qword_list(text, strend)? <.> &{ text == strend }

qword_list(lft,rgt) = qstring(SPACES + [rgt]):i word_space+ qword_list(lft,rgt):l { [str(i)] + l }
                    | qstring(SPACES + [rgt]):i { [str(i)] }

qstring_item(stops) = "\\" newline { "" }
                    | "\\" < . > { escaped_char(text) }
                    | "#" !{ stops.include?('#') } dyn_string_part:d { d }
                    | !{ stops.include?("\n") } newline:nl { nl }
                    | < . > !{ stops.include?(text) } { text }
qstring(stops) = qstring_item(stops)*:s { s }

dyn_string_part = cvar:n ~variable_access(n)
                | ivar:n ~variable_access(n)
                | backref
                | gvar:n ~variable_access(n)
                | "{" - statements:s - "}" ~statements(s)


symbol = ":" sym:s { s }
sym = fname
    | cvar
    | ivar
    | gvar

dsym = ":" string1:s { str(s) }
     | "%s" </[^A-Za-z0-9]/> { strend = string_end(text) } lstring([strend], [text]):s <.> &{ text == strend } { str(s) }

numeric = float:n { n }
        | integer:n { n }
        | "-" - float:n { n.negate = true; n }
        | "-" - integer:n { n.negate = true; n }

%% integer = ast Int(value, negate)
integer = "0" ("x" | "X") < /[0-9A-Fa-f]+/ ("_" < /[0-9A-Fa-f]+/ >)* > { integer(text.to_i(16), false) }
        | "0" ("d" | "D") < /[0-9]+/ ("_" < /[0-9]+/ >)* > { integer(text.to_i(10), false) }
        | "0" ("b" | "B") < /[0-1]+/ ("_" < /[0-1]+/ >)* > { integer(text.to_i(8), false) }
        | "0" ("o" | "O")? < /[0-7]+/ ("_" < /[0-7]+/ >)* > { integer(text.to_i(2), false) }
        | "0" { integer(0, false) }
        | < /[1-9][0-9]*/ ("_" < /[0-9]+/ >)* > { integer(text.to_i(10), false) }

%% float = ast Float(value, negate)
# TODO: underscores
         float = < /[0-9]+/ (/\.[0-9]*/ float_exponent? | float_exponent) > { float(text.to_f, false) }
float_exponent = /[eE][-+]?[0-9]+/

%% nil_ = ast Nil()
%% self_ = ast Self()
%% true_ = ast True()
%% false_ = ast False()
%% file = ast File()
%% line = ast Line()
variable = name:n ~variable_access(n)
         | cvar:n ~variable_access(n)
         | ivar:n ~variable_access(n)
         | gvar:n ~variable_access(n)
         | constant:c ~constant_access(c)
         | kw("nil") ~nil_()
         | kw("self") ~self_()
         | kw("true") ~true_()
         | kw("false") ~false_()
         | kw("__FILE__") ~file()
         | kw("__LINE__") ~line()

backref = "$" /[&`'+]|[1-9][0-9]+/

superclass = s "<" - expr(false):e term { e }
           | term { nil }

f_arglist = "(" - f_args:a - opt_nl - ")" { a }
          | f_args:a term { a }

f_args_tail = f_optarg:o - "," - f_rest_arg:s opt_f_block_arg:b { o + s + b }
            | f_optarg:o - opt_f_block_arg:b { o + b }
            | f_rest_arg:s - opt_f_block_arg:b { s + b }
            | f_norm_arg:n - "," - f_args_tail:l { [[:req, n]] + l }
            | f_norm_arg:n opt_f_block_arg:b { [[:req, n]] + b }

f_args = f_args_tail:l { l }
       | f_block_arg:b { [b] }
       | none { [] }
#f_args = f_arg:a - "," - f_optarg:o - "," - f_rest_arg:s opt_f_block_arg:b { a + o + s + b }
#       | f_arg:a - "," - f_optarg:o opt_f_block_arg:b { a + o + b }
#       | f_arg:a - "," - f_rest_arg:s opt_f_block_arg:b { a + s + b }
#       | f_arg:a opt_f_block_arg:b { a + b }
#       | f_optarg:o - "," - f_rest_arg:s opt_f_block_arg:b { o + s + b }
#       | f_optarg:o opt_f_block_arg:b { o + b }
#       | f_rest_arg:s opt_f_block_arg:b { s + b }
#       | f_block_arg:b { [b] }
#       | none { [] }

f_norm_arg = constant { error }
           | cvar { error }
           | ivar { error }
           | gvar { error }
           | name

constant = < /[A-Z][A-Za-z0-9_]*/ > { text }
cvar = < "@@" word > { text }
ivar = < "@" word > { text }
gvar = < "$" word > { text }
     | < "$" /[~*$?!@;,.=:<>\/\\"]/ > { text }
     | < "$-" /[A-Za-z0-9]/ > { text }

#f_arg = f_arg:l - "," - f_norm_arg:n { l << [:req, n] }
#      | f_norm_arg:n { [[:req, n]] }


f_opt = name:n - "=" - arg(false):v { [:opt, n, v] }

f_optarg = f_optarg:l - "," - f_opt:a { l + [a] }
         | f_opt:a { [a] }

f_rest_arg = "*" name:n { [:rest, n] }
           | "*" { [:rest] }

f_block_arg = "&" name:n { [:block, n] }
opt_f_block_arg = - "," - f_block_arg:b { [b] }
                | none { [] }

singleton = variable:v { v }
          | "(" - expr(false):e - opt_nl - ")" { e }

assoc_list = assocs(false):a trailer { a }
           | args(false):a trailer { a }
           | none { [] }

assocs(strict) = assocs(strict):l - "," - assoc(false):x { l + x }
               | assoc(strict):x { x }

assoc(strict) = arg(strict):k - "=>" - arg(false):v { [k,v] }

operation = fid:f { f }
          | name:i { i }
          | constant:c { c }

operation2 = fid:f { f }
           | identifier:i { i }
           | constant:c { c }
           | < opmethod > { text }

operation3 = fid:f { f }
           | identifier:i { i }
           | < opmethod > { text }

identifier = < /[a-z_][A-Za-z0-9_]*/ > { text }
name = < identifier > !{ RESERVED.include?(text) } { text }

word = < /[A-Za-z_][A-Za-z0-9_]*/ > { text }

kw(w) = < word /[?!]?/ > &{ text == w } { w }

fid = < /[A-Za-z0-9_]+[!?]/ > { text }

dot_or_colon = "." | "::"

opt_nl = newline?

%% heredoc_ = ast HereDoc(term, indent, value, dynamic)

newline = < ("\r" "\n"? | "\n") > @pending_heredocs { text }

pending_heredocs = &{ h = pop_heredoc } @pending_heredocs heredoc(h)
                 | &{ true }
heredoc_stop(h) = < (/[^\r\n]*(?:\r\n?|\n)/ | /[^\r\n]*/ eof) > &{ h.stop?(text) }
heredoc_line(h) = &{ h.dynamic } !heredoc_stop(h) qstring(NEWLINE):items newline:nl { items + [nl] }
                | !{ h.dynamic } !heredoc_stop(h) lstring(NEWLINE, []):items newline:nl { items + [nl] }
heredoc(h) = heredoc_line(h)*:lines heredoc_stop(h) { lines.each do |l| l.each do |atom| h.value.parts << atom end end; h.collapse; nil }

trailer = (newline | ",")?

opt_terms = terms?
term = s ";" | s newline
terms = terms s ";"
      | term

none = &{ true }

