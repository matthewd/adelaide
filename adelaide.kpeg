%% name = Adelaide::Parser
%% {

# The big ambiguities:
#  / -- divide vs regexp
#  : -- symbol vs ternary vs "then" vs ::
#  << -- heredoc vs lshift

  attr_accessor :ast

  attr_accessor :heredocs

  def setup
    @heredocs = []
  end

  SPACES = ["\t", "\n", "\v", "\f", "\r", ' ', "\r\n"]
  NEWLINE = ["\r", "\n", "\r\n"]
  def string_end(c)
    case c
    when '('; ')'
    when '['; ']'
    when '<'; '>'
    when '{'; '}'
    else; c
    end
  end


  # Iron out consecutive literal string-parts, then decide whether this
  # is a dstr
  def str(parts)
    x = []
    parts.each do |part|
      if String === x.last && String === part
        x.last << part
      else
        x << part.dup
      end
    end
    x = x.map {|part| String === part ? str_(part) : part }

    if x.size == 1 && AST::String === x.first
      x.first
    else
      dstr_(x)
    end
  end

  def escaped_char(c)
    case c
    when 'n'; "\n"
    when 't'; "\t"
    when 'r'; "\r"
    when 'f'; "\f"
    when 'v'; "\v"
    when 'a'; "\a"
    when 'e'; "\e"
    when 'b'; "\b"
    when 's'; "\s"
    when "\n"; ""
    else; c
    end
  end

  module AST; end
  class AST::Node
  end

  class AST::HereDoc < AST::Node
    def collapse
      @value = @value.collapse
    end
    def stop?(line)
      (@indent ? line.strip : line.chomp) == @stop
    end
  end
  class AST::LocalSend < AST::Node
    attr_writer :block
    def as_command(args,block)
      @args, @block = args, block
      self
    end
    def op_assignment(op, value)
      AST::OpAssign0.new(AST::VariableAccess.new(@name), op, value)
    end
  end
  class AST::ObjSend < AST::Node
    attr_writer :block
    def as_command(args,block)
      @args, @block = args, block
      self
    end
    def op_assignment(op, value)
      if name == '[]'
        AST::OpAssign1.new(@target, @args, op, value)
      else
        AST::OpAssign2.new(@target, @name, op, value)
      end
    end
  end
  class AST::VariableAccess < AST::Node
    def as_command(args,block)
      AST::LocalSend.new(@name, args, block)
    end
    def op_assignment(op, value)
      AST::OpAssign0.new(self, op, value)
    end
  end
  class AST::ConstantAccess < AST::Node
    def as_command(args,block)
      AST::LocalSend.new(@name, args, block)
    end
    def op_assignment(op, value)
      AST::OpAssign0.new(self, op, value)
    end
  end
  class AST::ScopedConstant < AST::Node
    def as_command(args,block)
      AST::ObjSend.new(@parent, @name, args, block)
    end
  end
  class AST::DString < AST::Node
    def collapse
      x = []
      parts.each do |part|
        if ::String === x.last && ::String === part
          x.last << part
        else
          x << part
        end
      end
      x = x.map {|part| ::String === part ? AST::String.new(part) : part }

      @parts = x

      if parts.size == 1 && AST::String === parts.first
        parts.first
      else
        self
      end
    end
  end

  def heredoc(stop, indent, value, dynamic)
    h = heredoc_(stop, indent, value, dynamic)
    @heredocs << h
    h
  end
  def pop_heredoc
    @heredocs.pop
  end


  def command_candidate?(candidate)
    case candidate
    when AST::LocalSend, AST::ObjSend
      candidate.args.nil? && candidate.block.nil?
    when AST::VariableAccess
      candidate.name !~ /^[@$]/
    when AST::ConstantAccess
      true
    when AST::ScopedConstant
      true
    else
      false
    end
  end

  def assignment_candidate?(candidate, op)
    case candidate
    when AST::LocalSend
      candidate.args.nil? && candidate.block.nil?
    when AST::ObjSend
      candidate.args.nil? && candidate.block.nil? ||
        candidate.name == "[]"
    when AST::ToplevelConstant, AST::ScopedConstant
      !op
    when AST::ConstantAccess, AST::VariableAccess
      true
    else
      false
    end
  end


  RESERVED = %w(
    __LINE__ __FILE__ BEGIN END alias and begin break case class def
    defined? do else elsif end ensure false for in module next nil not
    or redo rescue retry return self super then true undef when yield
    if unless while until
  )
}

eof = !.

space_element = hspace | newline | comment | escaped_newline
escaped_newline = "\\" newline
comment = /#[^\r\n]*/
hspace = /[ \t\v\f]+/

any_whitespace = /[ \t\n\r\n]/

wsp = space_element+
- = space_element*
sp = (hspace | comment | escaped_newline)+
s = (hspace | comment | escaped_newline)*

%% root = ast Root(value)

root = { setup } rd_doc* program:r - eof { @ast = root(r) }
program = statements

statements = - stmts:s opt_terms { s }

%% body = ast Body(stmts, rescue_, else_, ensure_)
block_body = statements:a (- rescue_clause)*:b - else_clause?:c - ensure_clause?:d ~body(a,b,c,d)

stmts = stmts:l terms - statement:s { l + [s] }
      | statement:s { [s] }
      | none { [] }

%% big_begin = ast BigBegin(value)
%% big_end = ast BigEnd(value)
%% undef_ = ast Undef(name)
statement = statement:v s kw("if") - expr(false, false):c ~if_([maybe(c,v)])
          | statement:v s kw("unless") - expr(false, false):c ~unless_(c,v,nil)
          | statement:v s kw("while") - expr(false, false):c ~while_(c,v)
          | statement:v s kw("until") - expr(false, false):c ~until_(c,v)
          | statement:v s kw("rescue") - statement:f ~recover(v,f)
          | alias_statement:a { a }
          | kw("undef") - undef_list:l ~l
          | kw("BEGIN") - "{" - statements:s - "}" ~big_begin(s)
          | kw("END") - "{" - statements:s - "}" ~big_end(s)
          | lhs(false):l s "=" !"=" !">" !"~" - mrhs:v ~assign(l,v)
          | mlhs:l s "=" !"=" !">" !"~" - mrhs:v ~assign(l,v)
          | lhs(false):l s "=" !"=" !">" !"~" - command_call(false, false):v ~assign(l,v)
          | mlhs:l s "=" !"=" !">" !"~" - command_call(false, false):v ~assign(l,v)
          | mlhs:l s "=" !"=" !">" !"~" - arg(false, false):v ~assign(l,v)
          | primary(false, false):t &{ assignment_candidate?(t, true) } s op_asgn:o - command_call(false, false):v { t.op_assignment(o,v) }
          | expr(false, false):e { e }

%% alias_ = ast Alias(from, to)
%% valias = ast VAlias(from, to)
alias_statement = kw("alias") - fitem:a - fitem:b ~alias_(a,b)
                | kw("alias") - gvar:a - gvar:b ~valias_(a,b)
                | kw("alias") - gvar:a - backref:b ~valias_(a,b) # FIXME: might be a n-ref, which should error

%% and_ = ast And(left, right)
%% or_ = ast Or(left, right)
%% not_ = ast Not(value)
expr(strict, no_do) = expr(strict, no_do):l - kw("and") - expr2(false, no_do):r ~and_(l,r)
             | expr(strict, no_do):l - kw("or") - expr2(false, no_do):r ~or_(l,r)
             | expr2(strict, no_do):e { e }
expr2(strict, no_do) = kw("not") - expr2(false, no_do):e ~not_(e)
              | "!" - expr2(false, no_do):e ~not_(e)
              | command_call(strict, no_do):c { c }
              | arg(strict, no_do):a { a }

%% return_ = ast Return(value)
%% break_ = ast Break(value)
%% next_ = ast Next(value)
%% yield_ = ast Yield(value)
%% super_ = ast Super(value)
%% redo_ = ast Redo()
%% retry_ = ast Retry()

%% defined_ = ast Defined(value)

command_call(strict, no_do) = !{ no_do } block_call(strict):t dot_or_colon - operation2:n command_args(no_do):a ~obj_send(t,n,a,nil)
                            | !{ no_do } block_call(strict):c command_args(no_do):a &{ command_candidate?(c) } { c.as_command(a,nil) }
                            | !{ no_do } block_call(strict):c { c }
                            | command(strict, no_do):c { c }
                            | kw("return") s command_call(false, no_do):v ~return_(v)
                            | kw("return") s loose_call_args(no_do):v ~return_(v)
                            | kw("break") s command_call(false, no_do):v ~break_(v)
                            | kw("break") s loose_call_args(no_do):v ~break_(v)
                            | kw("next") s command_call(false, no_do):v ~next_(v)
                            | kw("next") s loose_call_args(no_do):v ~next_(v)


%% block = ast Block(vars, body)
cmd_brace_block = "{" - opt_block_var:v - statements:s - "}" ~block(v,s)

command(strict, no_do) = &{ false }
                | kw("super") command_args(no_do):v ~super_(v)
                | kw("yield") command_args(no_do):v ~yield_(v)
                | primary(strict, no_do):c &{ command_candidate?(c) } command_args(no_do):a (s cmd_brace_block)?:b { c.as_command(a,b) }

mlhs = "(" - mlhs:i - ")" { [i] }
     | mlhs_head:l - mlhs_item:i { l + [i] }
     | mlhs_head:l - splat_lhs:i { l + [splat(i)] }
     | mlhs_head:l { l }
     | splat_lhs:i { [splat(i)] }

mlhs_head = mlhs_head:l - mlhs_item:i - "," { l + [i] }
          | mlhs_item:i - "," { [i] }

mlhs_item = "(" - mlhs:i - ")" { i }
          | mlhs_node(false):i { i }

mlhs_node(no_do) = primary(false, no_do):t &{ assignment_candidate?(t, false) } ~t
          | "::" - constant:c ~toplevel_constant(c)
          | variable

lhs(no_do) = mlhs_node(no_do)

cname = identifier
      | constant

cpath = primary(false, false):v &{ AST::ScopedConstant === v || AST::ToplevelConstant === v  || AST::ConstantAccess === v } ~v

fname = fid
      | identifier "="?
      | constant "="?
      | < opmethod > { text }

fitem = fname
      | symbol
      | dsym

undef_list = undef_list:l s "," - fitem:i { l + [undef_(i)] }
           | fitem:i ~undef_(i)

opmethod = "[]="
         | "[]"
         | "<=>"
         | "==="
         | "=="
         | "=~"
         | "<<"
         | ">>"
         | ">="
         | "<="
         | ">"
         | "<"
         | "+@"
         | "-@"
         | "**"
         | "+"
         | "-"
         | "*"
         | "/"
         | "%"
         | "~"
         | "|"
         | "^"
         | "&"
         | "`"

op_asgn = < "**="
          | "*="
          | "<<="
          | ">>="
          | "&&="
          | "&="
          | "||="
          | "|="
          | "+="
          | "-="
          | "/="
          | "^="
          | "%="
          > { text[0..-2] }

%% assign = ast Assign(lhs,rhs)
%% binop = ast BinOp(op,left,right)
%% range = ast Range(left,right,open)

%% unary_plus = ast UnaryPlus(value)
%% unary_minus = ast UnaryMinus(value)

%% recover = ast Recover(attempt, fallback)

%% op_assign_0 = ast OpAssign0(target,op,value)
%% op_assign_1 = ast OpAssign1(target,index,op,value)
%% op_assign_2 = ast OpAssign2(target,name,op,value)

arg(strict, no_do) = kw("defined?") - !"(" arg(false, no_do):v ~defined_(v)
                   | arg1(strict, no_do):c s "?" - arg(false, no_do):t - ":" - arg(false, no_do):f ~ternary(c,t,f)
                   | arg1(strict, no_do)

arg1(strict, no_do) = arg2(strict, true):l s ".." !"." - arg2(false, true):r ~range(l,r,false)
                    | arg2(strict, true):l s "..." - arg2(false, true):r ~range(l,r,true)
                    | arg2(strict, no_do)

arg2(strict, no_do) = arg2(strict, no_do):l s "||" !"=" - arg3(false, no_do):r { binop(:"||",l,r) }
                    | arg3(strict, no_do)

arg3(strict, no_do) = arg3(strict, no_do):l s "&&" !"=" - arg4(false, no_do):r { binop(:"&&",l,r) }
                    | arg4(strict, no_do)

arg4(strict, no_do) = arg4(strict, no_do):l s "<=>" - arg5(false, no_do):r { binop(:<=>,l,r) }
                    | arg4(strict, no_do):l s "==" !"=" - arg5(false, no_do):r { binop(:==,l,r) }
                    | arg4(strict, no_do):l s "===" - arg5(false, no_do):r { binop(:===,l,r) }
                    | arg4(strict, no_do):l s "!=" - arg5(false, no_do):r { binop(:"!=",l,r) }
                    | arg4(strict, no_do):l s "=~" - arg5(false, no_do):r { binop(:"=~",l,r) }
                    | arg4(strict, no_do):l s "!~" - arg5(false, no_do):r { binop(:"!~",l,r) }
                    | arg5(strict, no_do)

arg5(strict, no_do) = arg5(strict, no_do):l s ">" !"=" !">" - arg6(false, no_do):r { binop(:>,l,r) }
                    | arg5(strict, no_do):l s ">=" - arg6(false, no_do):r { binop(:>=,l,r) }
                    | arg5(strict, no_do):l s "<" !"=" !"<" - arg6(false, no_do):r { binop(:<,l,r) }
                    | arg5(strict, no_do):l s "<=" !">" - arg6(false, no_do):r { binop(:<=,l,r) }
                    | arg6(strict, no_do)

arg6(strict, no_do) = arg6(strict, no_do):l s "|" !"|" !"=" - arg7(false, no_do):r { binop(:|,l,r) }
                    | arg6(strict, no_do):l s "^" !"=" - arg7(false, no_do):r { binop(:^,l,r) }
                    | arg7(strict, no_do)

arg7(strict, no_do) = arg7(strict, no_do):l s "&" !"&" !"=" - arg8(false, no_do):r { binop(:&,l,r) }
                    | arg8(strict, no_do)

arg8(strict, no_do) = arg8(strict, no_do):l s "<<" !"=" - arg9(false, no_do):r { binop(:<<,l,r) }
                    | arg8(strict, no_do):l s ">>" !"=" - arg9(false, no_do):r { binop(:>>,l,r) }
                    | arg9(strict, no_do)

arg9(strict, no_do) = arg9(strict, no_do):l s "+" !"=" - arg10(false, no_do):r { binop(:+,l,r) }
                    | arg9(strict, no_do):l s "-" !"=" - arg10(false, no_do):r { binop(:-,l,r) }
                    | arg10(strict, no_do)

arg10(strict, no_do) = arg10(strict, no_do):l s "*" !"*" !"=" - arg11(false, no_do):r { binop(:*,l,r) }
                     | arg10(strict, no_do):l s "/" !"=" - arg11(false, no_do):r { binop(:/,l,r) }
                     | arg10(strict, no_do):l s "%" !"=" - arg11(false, no_do):r { binop(:%,l,r) }
                     | arg11(strict, no_do)

arg11(strict, no_do) = "-" !numeric arg11(false, no_do):v ~unary_minus(v)
                     | !{ strict } !numeric "-" - arg11(false, no_do):v ~unary_minus(v)
                     | "-" numeric:l s "**" !"=" - arg11(false, no_do):r { unary_minus(binop(:**,l,r)) }
                     | arg12(strict, no_do)

arg12(strict, no_do) = arg13(strict, no_do):l s "**" !"=" - arg11(false, no_do):r ~binop(l,r)
                     | arg13(strict, no_do)

arg13(strict, no_do) = "!" - arg11(false, no_do):v ~logical_not(v)
                     | "~" - arg11(false, no_do):v ~bit_not(v)
                     | "+" arg11(false, no_do):v ~unary_plus(v)
                     | !{ strict } "+" - arg11(false, no_do):v ~unary_plus(v)
                     | lhs(no_do):l s "=" !"=" !">" !"~" - arg(false, no_do):v s kw("rescue") - arg(false, no_do):r ~assign(l,recover(v,r))
                     | lhs(no_do):l s "=" !"=" !">" !"~" - arg(false, no_do):v ~assign(l,v)
                     | primary(strict, no_do):t &{ assignment_candidate?(t, true) } s op_asgn:o - arg(false, no_do):v { t.op_assignment(o,v) }
                     | primary(strict, no_do)


%% hash = ast Hash(elements)
%% array = ast Array(elements)

%% ternary = ast Ternary(cond,t,f)
%% lshift = ast LShift(left,right)
%% rshift = ast RShift(left,right)
%% bit_and = ast BitAnd(left,right)
%% bit_or = ast BitOr(left,right)
%% bit_xor = ast BitXOr(left,right)
%% bit_not = ast BitNot(value)

%% splat = ast Splat(value)
%% amplify = ast Amplify(value)

aref_args = assocs(false, false):l (- ",")? &(- "]") { l }
          | "*" arg(false, false):s &(- "]") { [splat(s)] }
          | command(false, false):v &(- "]") { [v] }
          | args(false, false):l - "," - "*" arg(false, false):s &(- "]") { l + [splat(s)] }
          | args(false, false):l (- ",")? &(- "]") { l }
          | none &(- "]") { [] }

paren_args = "(" - ")" { [] }
           | "(" - call_args(false, false):a - ")" { a }
           | "(" - block_call(false):b - ")" { [b] }
           | "(" - args(false, false):a - "," - block_call(false):b - ")" { a + [b] }
           | sp paren_args:a { a }

loose_call_args(no_do) = !kw("if") !kw("unless") !kw("while") !kw("until") call_args(true, no_do):a ~a
call_args(strict, no_do) = &{false} # command(strict, no_do):c { [c] }
                  | assocs(strict, no_do):h s "," - "*" arg(false, no_do):s opt_block_arg(no_do):b { [hash(h), splat(s)] + b }
                  | assocs(strict, no_do):h opt_block_arg(no_do):b { [hash(h)] + b }
                  | args(strict, no_do):a s "," - assocs(false, no_do):h s "," - "*" arg(false, no_do):s opt_block_arg(no_do):b { a + [hash(h), splat(s)] + b }
                  | args(strict, no_do):a s "," - assocs(false, no_do):h opt_block_arg(no_do):b { a + [hash(h)] + b }
                  | args(strict, no_do):a s "," - "*" arg(false, no_do):s opt_block_arg(no_do):b { a + [splat(s)] + b }
                  | arg(strict, no_do):a s "," - args(strict, no_do):l opt_block_arg(no_do):b { [a] + l + b }
                  | command(strict, no_do):c { [c] }
                  | args(strict, no_do):a opt_block_arg(no_do):b { a + b }
                  | "*" arg(false, no_do):s opt_block_arg(no_do):b { [splat(s)] + b }
                  | block_arg(no_do):b { [b] }


command_args(no_do) = !"(" !"[" !"{" !"/" !"%" !"-" !"+" !"<<" s loose_call_args(no_do):a { a }

block_arg(no_do) = "&" - arg(false, no_do):v ~amplify(v)
opt_block_arg(no_do) = - "," - block_arg(no_do):v { [v] }
              | none { [] }

args(strict, no_do) = args(strict, no_do):l s "," - arg(false, no_do):v !(s "=>") { l + [v] }
             | arg(strict, no_do):v !(s "=>") { [v] }

mrhs = args(false, false):l &{ l.size > 1 } { l }
     | args(false, false):l s "," - "*" arg(false, false):v { l + [splat(v)] }
     | "*" arg(false, false):v { [splat(v)] }

%% method_ = ast Method(obj,name,args,body)
%% if_ = ast If(parts)
%% unless_ = ast Unless(cond,true_value,false_value)
%% while_ = ast While(cond,value)
%% until_ = ast Until(cond,value)
%% case_ = ast Case(value,parts)

%% toplevel_constant = ast ToplevelConstant(name)
%% scoped_constant = ast ScopedConstant(parent, name)
%% constant_access = ast ConstantAccess(name)
%% variable_access = ast VariableAccess(name)

%% statements = ast Statements(value)

%% class_ = ast Class(name, superclass, body)
%% singleton_class = ast SingletonClass(value, body)
%% module_ = ast Module(name, body)

%% fid = ast Fid(s)

primary(strict, no_do) = primary(strict, no_do):t "[" - aref_args:a - "]" ~obj_send(t, "[]", a, nil)
                | primary(strict, no_do):t dot_or_colon - operation2:n paren_args:a s brace_block(no_do):b ~obj_send(t,n,a,b)
                | primary(strict, no_do):t dot_or_colon - operation2:n s brace_block(no_do):b ~obj_send(t,n,nil,b)
                | primary(strict, no_do):t dot_or_colon - operation2:n paren_args:a ~obj_send(t,n,a,nil)
                | primary(strict, no_do):t dot_or_colon - operation3:n ~obj_send(t,n,nil,nil)
                | primary(strict, no_do):t "::" - constant:c ~scoped_constant(t,c)
                | primary(strict, no_do):t s "." - constant:c ~obj_send(t,c,nil,nil)
                | operation:n paren_args:a s brace_block(no_do):b ~local_send(n,a,b)
                | operation:n paren_args:a ~local_send(n,a,nil)
                | operation:n s brace_block(no_do):b ~local_send(n,[],b)
                | kw("super") paren_args:v s brace_block(no_do):b
                | kw("super") paren_args:v ~super_(v)
                | kw("super") s brace_block(no_do):b
                | kw("super") ~super_(nil)
                | literal
                | strings(strict)
                | xstring
                | regexp(strict)
                | words
                | qwords
                | !"defined?" fid:n ~local_send(n,nil,nil)
                | variable
                | kw("begin") - block_body:b - kw("end") { b } ~statements(b)
                | "(" - expr(false, false):e - ")" { e }
                | "(" - statements:s - ")" ~statements(s)
                | "::" - constant:c ~toplevel_constant(c)
                | "[" - aref_args:a - "]" ~array(a)
                | "{" - assoc_list:l - "}" ~hash(l)
                | kw("return") ~return_(nil)
                | kw("yield") s "(" - call_args(false, false):v - ")" ~yield_(v)
                | kw("yield") s "(" - ")" ~yield_(nil)
                | kw("yield") ~yield_(nil)
                | kw("defined?") - "(" - expr(false, false):v - ")" ~defined_(v)
                | kw("if") - expr(false, no_do):e s then - statements:s - if_tail(no_do):l - kw("end") { if_([maybe(e,s)] + l) }
                | kw("unless") - expr(false, no_do):e s then - statements:s - else_clause?:f - kw("end") ~unless_(e,s,f)
                | kw("while") - expr(false, true):e s do - statements:s - kw("end") ~while_(e,s)
                | kw("until") - expr(false, true):e s do - statements:s - kw("end") ~until_(e,s)
                | kw("case") opt_terms - case_body:b - kw("end") ~case_(nil,b)
                | kw("case") - expr(false, no_do):e opt_terms - case_body:b - kw("end") ~case_(e,b)
                | kw("for") - for_var - kw("in") - expr(false, no_do) s do - statements - kw("end")
                | kw("class") - "<<" - expr(false, no_do) term:e - block_body:b - kw("end") ~singleton_class(e,b)
                | kw("class") - cpath:n superclass:s - block_body:b - kw("end") ~class_(n,s,b)
                | kw("module") - cpath:n - block_body:b - kw("end") ~module_(n,b)
                | kw("def") - fname:n s f_arglist:a - block_body:b - kw("end") ~method_(nil,n,a,b)
                | kw("def") - singleton:o dot_or_colon - fname:n s f_arglist:a - block_body:b - kw("end") ~method_(o,n,a,b)
                | kw("break") ~break_(nil)
                | kw("next") ~next_(nil)
                | kw("redo") ~redo_()
                | kw("retry") ~retry_()

then = ":"
     | kw("then")
     | term - kw("then")
     | term

do = term
   | ":"
   | kw("do")

%% maybe = ast Maybe(cond, value)
if_tail(no_do) = kw("elsif") - expr(false, no_do):c s then - statements:s - if_tail(no_do):l { [maybe(c,s)] + l }
        | else_clause:e { [e] }
        | none { [] }

%% else_ = ast Else(value)
else_clause = kw("else") - statements:s ~else_(s)

for_var = mlhs
        | lhs(false)

block_par = block_par:l - "," - mlhs_item:i { l + [[:lhs, i]] }
          | mlhs_item:i { [[:lhs, i]] }

block_var = block_par:l - "," - "&" - lhs(false):b { l + [[:block, b]] }
          | block_par:l - "," - splat_lhs:s - "," - "&" - lhs(false):b { l + [[:rest, s], [:block, b]] }
          | block_par:l - "," - splat_lhs:s { l + [[:rest, s]] }
          | block_par:l - "," { l }
          | block_par:l { l }
          | splat_lhs:s - "," - "&" - lhs(false):b { [[:rest, s], [:block, b]] }
          | splat_lhs:s { [[:rest, s]] }
          | "&" - lhs(false):b { [[:block, b]] }

splat_lhs = "*" - lhs(false):s { s }
          | "*" { nil }

opt_block_var = "|" - block_var?:v - "|" { v || [] }
              | none { [] }

do_block = kw("do") - opt_block_var:v - statements:b - kw("end") ~block(v,b)

block_call(strict) = block_call(strict):t dot_or_colon - operation2:n paren_args:a ~obj_send(t,n,a,nil)
                   | block_call(strict):t dot_or_colon - operation2:n ~obj_send(t,n,nil,nil)
                   | command(strict, false):c s do_block:b { c.block = b; c }

%% obj_send = ast ObjSend(target, name, args, block)
%% local_send = ast LocalSend(name, args, block)



brace_block(no_do) = "{" - opt_block_var:v - statements:b - "}" ~block(v,b)
                   | !{ no_do } kw("do") - opt_block_var:v - statements:b - kw("end") ~block(v,b)

%% when_ = ast When(cond, value)
when_clause = kw("when") - when_args:a s then - statements:s ~when_(a,s)

case_body = when_clause:w - case_body:l { [w] + l }
          | when_clause:w { [w] }
          | else_clause:e { [e] }

when_args = args(false, false):a - "," - "*" arg(false, false):s { a + [splat(s)] }
          | args(false, false):a { a + [nil] }
          | "*" arg(false, false):s { [splat(s)] }

%% rescue_ = ast Rescue(exceptions, var, value)
rescue_clause = kw("rescue") s exc_list?:l s exc_var:v s then - statements:s ~rescue_(l,v,s)

exc_list = exc_list:l s "," - arg(false, false):i { l + [i] }
         | arg(false, false):i { [i] }

exc_var = "=>" - lhs(false):v { v }
        | none { nil }

%% ensure_ = ast Ensure(value)
ensure_clause = kw("ensure") - statements:s ~ensure_(s)

%% symbol = ast Symbol(value)
%% dsymbol = ast DSymbol(value)

literal = numeric
        | symbol:s ~symbol(s)
        | dsym:s ~dsymbol(s)
        | char:c ~char(c)
%% char = ast Char(value)
char = "?" &"\\" char_escape:c { c }
     | "?" !any_whitespace <.> { text }
char_escape = "\\\\" { "\\" }
            | "\\x" /[0-9A-Fa-f]{2}/ { text.to_i(16).chr }
            | ("\\c" | "\\C-") char_escape:c { (c[0] & 0x9f).chr }
            | ("\\c" | "\\C-") <.> { (text[0] & 0x9f).chr }
            | "\\M-" char_escape:c { (c[0] | 0x80).chr }
            | "\\M-" <.> { (text[0] | 0x80).chr }
            | "\\" /[xcCM]/ { nil }
            | "\\" </[0-7]+/> { text.to_i(8).chr }
            | "\\" <.> { escaped_char(text) }

%% dstr_ = ast DString(parts)
%% str_ = ast String(value)

strings(strict) = string:s ~str(s)
                | "%Q" nesting_string(true):s ~str(s)
                | "%q" nesting_string(false):s ~str(s)
                | "%" !"=" !any_whitespace nesting_string(true):s ~str(s)
                | !{ strict } "%=" qstring(["="]):s "=" ~str(s)
                | "<<" <"-"?> heredoc_ref(text):r { r }

heredoc_ref(indent) = "'" < /[^']+/ > "'" { heredoc(text, indent != '', dstr_([]), false) }
                    | "\"" < /[^"]+/ > "\"" { heredoc(text, indent != '', dstr_([]), true) }
                    | "`" < /[^`]+/ > "`" { heredoc(text, indent != '', xstr_(dstr_([])), true) }
                    | < word > { heredoc(text, indent != '', dstr_([]), true) }

string = string:a s string1:b { a+b }
       | string1

string1 = "\"" qstring(["\""]):s "\"" { s }
        | "'" lstring(["'"], true):s "'" { s }

%% xstr_ = ast XString(str)
xstring = "`" qstring(["`"]):s "`" { xstr_(str(s)) }
        | "%x" nesting_string(true):s { xstr_(str(s)) }

%% regexp = ast RegExp(value, flags)
regexp(strict) = "/" !"=" !any_whitespace qstring(["/"]):s "/" re_flags:f ~regexp(str(s),f)
               | !{ strict } "/" qstring(["/"]):s "/" re_flags:f ~regexp(str(s),f)
               | "%r" nesting_string(true):s re_flags:f ~regexp(str(s),f)

re_flags = < /[A-Za-z]*/ > { text }

words = "%w" </[^A-Za-z0-9]/> { strend = string_end(text) } word_list(false, text, strend, 0)?:w &{ w[0] == 0 } <.> &{ text == strend } { w ? w[1] : [] }
qwords = "%W" </[^A-Za-z0-9]/> { strend = string_end(text) } word_list(true, text, strend, 0)?:w &{ w[0] == 0 } <.> &{ text == strend } { w ? w[1] : [] }

word_space = newline
           | " "
           | "\t"
           | "\v"
           | "\f"

word_part(q,lft,rgt,d) = &{ lft != rgt } word_part(q,lft,rgt,d):a word_part(q,lft,rgt,a[0]):b { [b[0], a[1] + b[1]] }
                       | &{ lft != rgt } <.> &{ text == lft } { [d + 1, [lft]] }
                       | &{ lft != rgt } <.> &{ d > 0 && text == rgt } { [d - 1, [rgt]] }
                       | !{ q } lstring(SPACES + [lft, rgt], true):i { [d, i] }
                       | &{ q } qstring(SPACES + [lft, rgt]):i { [d, i] }
word_list(q,lft,rgt,d) = word_part(q,lft,rgt,d):i word_space+ word_list(q,lft,rgt,i[0]):l { [l[0], [str(i[1])] + l[1]] }
                       | word_part(q,lft,rgt,d):i { [i[0], [str(i[1])]] }

nesting_string(q) = </[^A-Za-z0-9]/> { strend = string_end(text) } nesting_string_part(q,text,strend)?:s <.> &{ text == strend } { s || [] }
nesting_string_part(q,lft,rgt) = &{ lft != rgt } nesting_string_part(q,lft,rgt):a nesting_string_part(q,lft,rgt):b { a + b }
                               | &{ lft != rgt } <.> &{ text == lft } nesting_string_part(q,lft,rgt):i <.> &{ text == rgt } { [lft] + i + [rgt] }
                               | !{ q } lstring([lft, rgt], true):i { i }
                               | &{ q } qstring([lft, rgt]):i { i }

lstring(stops,escapes) = lstring_item(stops,escapes)*:s { s }
lstring_item(stops,escapes) = !{ stops.include?("\\") } &{ stops.include?("\n") } "\\" newline:nl { nl }
                            | !{ stops.include?("\\") } "\\" < . > &{ stops.include?(text) } { text }
                            | !{ stops.include?("\\") } "\\\\" &{ escapes } { "\\" }
                            | !{ stops.include?("\n") } newline:nl { nl }
                            | < . > !{ stops.include?(text) } { text }

qstring(stops) = qstring_item(stops)*:s { s }
qstring_item(stops) = !{ stops.include?("\\") } "\\" newline { "" }
                    | !{ stops.include?("\\") } "\\" < . > { escaped_char(text) }
                    | !{ stops.include?('#') } "#" dyn_string_part:d { d }
                    | !{ stops.include?("\n") } newline:nl { nl }
                    | < . > !{ stops.include?(text) } { text }

dyn_string_part = cvar:n ~variable_access(n)
                | ivar:n ~variable_access(n)
                | backref:n ~variable_access(n)
                | gvar:n ~variable_access(n)
                | "{" - statements:s - "}" ~statements(s)


symbol = ":" sym:s { s }
sym = fname
    | cvar
    | ivar
    | gvar
    | backref

dsym = ":" string1:s { str(s) }
     | "%s" nesting_string(false):s { str(s) }

numeric = float:n { n }
        | integer:n { n }

%% integer = ast Int(value)
integer = "-"?:neg "0" ("x" | "X") < /[0-9A-Fa-f]+/ ("_" /[0-9A-Fa-f]+/)* > { n = text.gsub('_','').to_i(16); integer(neg ? -n : n) }
        | "-"?:neg "0" ("d" | "D") < /[0-9]+/ ("_" /[0-9]+/)* > { n = text.gsub('_','').to_i(10); integer(neg ? -n : n) }
        | "-"?:neg "0" ("b" | "B") < /[0-1]+/ ("_" /[0-1]+/)* > { n = text.gsub('_','').to_i(8); integer(neg ? -n : n) }
        | "-"?:neg "0" ("o" | "O")? < /[0-7]+/ ("_" /[0-7]+/)* > { n = text.gsub('_','').to_i(2); integer(neg ? -n : n) }
        | "0" { integer(0) }
        | < /-?[1-9][0-9]*/ ("_" /[0-9]+/)* > { integer(text.gsub('_','').to_i(10)) }

%% float = ast Float(value)
         float = < /-?[0-9]+/ ("_" /[0-9]+/)* (/\.[0-9]+/ ("_" /[0-9]+/)* float_exponent? | float_exponent) > { float(text.gsub('_','').to_f) }
float_exponent = /[eE][-+]?[0-9]+/ ("_" /[0-9]+/)*

%% nil_ = ast Nil()
%% self_ = ast Self()
%% true_ = ast True()
%% false_ = ast False()
%% file = ast File()
%% line = ast Line()
variable = name:n ~variable_access(n)
         | cvar:n ~variable_access(n)
         | ivar:n ~variable_access(n)
         | gvar:n ~variable_access(n)
         | backref:n ~variable_access(n)
         | constant:c ~constant_access(c)
         | kw("nil") ~nil_()
         | kw("self") ~self_()
         | kw("true") ~true_()
         | kw("false") ~false_()
         | kw("__FILE__") ~file()
         | kw("__LINE__") ~line()

backref = "$" /[&`'+]|[1-9][0-9]*/

superclass = s "<" - expr(false, false):e term { e }
           | term { nil }

f_arglist = "(" - f_args:a - ")" { a }
          | f_args:a term { a }

f_args_tail = f_optarg:o - "," - f_rest_arg:s opt_f_block_arg:b { o + s + b }
            | f_optarg:o opt_f_block_arg:b { o + b }
            | f_rest_arg:s opt_f_block_arg:b { s + b }
            | f_norm_arg:n - "," - f_args_tail:l { [[:req, n]] + l }
            | f_norm_arg:n opt_f_block_arg:b { [[:req, n]] + b }

f_args = f_args_tail:l { l }
       | f_block_arg:b { [b] }
       | none { [] }

f_norm_arg = constant { error }
           | cvar { error }
           | ivar { error }
           | gvar { error }
           | name

constant = < /[A-Z](?:[A-Za-z0-9_]|[^\0-\177])*/ > { text }
cvar = < "@@" word > { text }
ivar = < "@" word > { text }
gvar = < "$" word > { text }
     | < "$" /[0~*$?!@;,.=:<>\/\\"]/ > { text }
     | < "$-" /[A-Za-z0-9]/ > { text }

f_opt = name:n - "=" - arg(false, false):v { [:opt, n, v] }

f_optarg = f_optarg:l - "," - f_opt:a { l + [a] }
         | f_opt:a { [a] }

f_rest_arg = "*" name:n { [[:rest, n]] }
           | "*" { [[:rest]] }

f_block_arg = "&" name:n { [:block, n] }
opt_f_block_arg = - "," - f_block_arg:b { [b] }
                | none { [] }

singleton = variable:v { v }
          | "(" - expr(false, false):e - ")" { e }

assoc_list = assocs(false, false):a trailer { a }
           | args(false, false):a trailer { a }
           | none { [] }

assocs(strict, no_do) = assocs(strict, no_do):l - "," - assoc(false, no_do):x { l + x }
               | assoc(strict, no_do):x { x }

assoc(strict, no_do) = arg(strict, no_do):k - "=>" - arg(false, no_do):v { [k,v] }

operation = !"defined?" fid:f { f }
          | name:i { i }
          | constant:c { c }

operation2 = fid:f { f }
           | identifier:i { i }
           | constant:c { c }
           | < opmethod > { text }

operation3 = fid:f { f }
           | identifier:i { i }
           | < opmethod > { text }

identifier = < /(?:[a-z_]|[^\0-\177])(?:[A-Za-z0-9_]|[^\0-\177])*/ > { text }
name = < (fid | identifier) > !{ RESERVED.include?(text) } { text }

word = < /(?:[A-Za-z_]|[^\0-\177])(?:[A-Za-z0-9_]|[^\0-\177])*/ > { text }

kw(w) = < word /[?!]?/ > &{ text == w } { w }

fid = < /[A-Za-z0-9_]+[!?]/ > { text }

dot_or_colon = s "."
             | "::"

%% heredoc_ = ast HereDoc(stop, indent, value, dynamic)

newline = < ("\r" "\n"? | "\n") > @pending_heredocs rd_doc* { text }
rd_doc = "=begin" (!"=end" /[^\r\n]*(?:\r\n?|\n)/)+ "=end" /[^\r\n]*(?:\r\n?|\n)/

pending_heredocs = &{ h = pop_heredoc } @pending_heredocs heredoc(h)
                 | &{ true }
heredoc_stop(h) = < (/[^\r\n]*(?:\r\n?|\n)/ | /[^\r\n]*/ eof) > &{ h.stop?(text) }
heredoc_line(h) = &{ h.dynamic } !heredoc_stop(h) qstring(NEWLINE):items newline:nl { items + [nl] }
                | !{ h.dynamic } !heredoc_stop(h) lstring(NEWLINE, false):items newline:nl { items + [nl] }
heredoc(h) = heredoc_line(h)*:lines (heredoc_stop(h) | fail(h)) { lines.each do |l| l.each do |atom| h.value.parts << atom end end; h.collapse; nil }

trailer = (newline | ",")?

opt_terms = terms?
term = s ";" | s newline
terms = terms s ";"
      | term

none = &{ true }

fail(s) = { raise "Parse failed: #{s.inspect}" }
dbg = &debug(nil)
debug(s) = </(\n|\r|.){0,20}/> { ls = caller.map {|x| x.sub!(::Regexp.new(".*`_(.*)'$"), '\1') }.compact; ls.shift if ls.first == 'dbg'; px = ls.first; p ls; px = px+": #{s}" if s; puts "#{px}: #{text.inspect}" }

