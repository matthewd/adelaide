%% name = Adelaide::Parser
%% {

# The big ambiguities:
#  / -- divide vs regexp
#  : -- symbol vs ternary vs "then" vs ::
#  << -- heredoc vs lshift

  attr_accessor :ast
  attr_accessor :line_offset
  def lineno; @lines[pos] ||= current_line + (@line_offset || 0); end

  attr_accessor :heredocs

  def setup
    @heredocs = []
    @lines = {}
  end

  SPACES = ["\t", "\n", "\v", "\f", "\r", ' ', "\r\n"]
  NEWLINE = ["\r", "\n", "\r\n"]
  def string_end(c)
    case c
    when '('; ')'
    when '['; ']'
    when '<'; '>'
    when '{'; '}'
    else; c
    end
  end

  class Cx
    def self.strict; new.strict; end
    def self.no_do; new.no_do; end

    def initialize
      @strict = false
      @no_do = false
    end

    def strict?; @strict; end
    def no_do?; @no_do; end

    def strict; with(:strict); end
    def no_do; with(:no_do); end

    def with(t)
      x = dup
      x.instance_variable_set(:"@#{t}", true)
      x
    end

    def unstrict; without(:strict); end
    def unno_do; without(:no_do); end

    def without(t)
      x = dup
      x.instance_variable_set(:"@#{t}", false)
      x
    end

    def left
      self
    end
    def right
      unstrict
    end

    def eql?(other)
      other.strict? == strict? &&
        other.no_do? == no_do?
    end
    def hash
      n = 1
      n <<= 1; n |= 1 if strict?
      n <<= 1; n |= 1 if no_do?
      n
    end
  end

  AST = ::Rubinius::AST


  # Iron out consecutive literal string-parts, then decide whether this
  # is a dstr
  def AST.str(line, parts, static=AST::StringLiteral, dynamic=AST::DynamicString, *extra)
    x = []
    parts.each do |part|
      if ::String === x.last && ::String === part
        x.last << part
      else
        x << part.dup
      end
    end
    front = ""
    front = x.shift if ::String === x.first
    x = x.map {|part| ::String === part ? AST::StringLiteral.new(line, part) : AST::ToString.new(line, part) }

    if x.empty?
      if block_given?
        static.new(line, yield(front), *extra)
      else
        static.new(line, front, *extra)
      end
    else
      dynamic.new(line, front, x, *extra)
    end
  end

  def regex_flags(s)
    0
  end

  def escaped_char(c)
    case c
    when 'n'; ?\n
    when 't'; ?\t
    when 'r'; ?\r
    when 'f'; ?\f
    when 'v'; ?\v
    when 'a'; ?\a
    when 'e'; ?\e
    when 'b'; ?\b
    when 's'; ?\s
    else; c[0]
    end
  end


  Heredoc = Struct.new(:target, :stop, :indent, :dynamic)
  class Heredoc
    def stop?(line)
      (@indent ? line.strip : line.chomp) == @stop
    end
    def append(strings)
      list = strings.flatten

      @target.string << list.shift while String === list.first

      until list.empty?
        if String === @target.array.last && String === list.first
          @target.array.last << list.shift
        elsif String === list.first
          @target.array << list.shift.dup
        else
          item = list.shift
          @target.array << AST::ToString.new(item.line, item)
        end
      end

      @target.array.each_with_index do |item, idx|
        @target.array[idx] = AST::StringLiteral.new(@target.line, item) if String === item
      end
    end
  end

  def heredoc(line, stop, indent, klass=nil)
    dynamic = !!klass
    if dynamic
      s = klass.new(line, "", [])
    else
      s = AST::StringLiteral.new(line, "")
    end

    @heredocs << Heredoc.new(s, stop, indent, dynamic)
    s
  end
  def pop_heredoc
    @heredocs.pop
  end


  def command_candidate?(candidate)
    case candidate
    when AST::Send, AST::ConstantAccess
      true
    when AST::Return
      candidate.value.nil?
    when AST::Next
      candidate.value.nil?
    when AST::Break
      candidate.value.nil?
    when AST::Yield
      candidate.value.nil?
    else
      false
    end
  end

  def as_command(call, args, block)
    case call
    when AST::Send
      if args
        x = AST::SendWithArguments.new(call.line, call.receiver, call.name, args, call.privately)
      else
        x = call
      end
      x.block = block
      x
    when AST::ConstantAccess
      if args
        x = AST::SendWithArguments.new(call.line, AST::Self.new(call.line), call.name, args, true)
      else
        x = AST::Send.new(call.line, AST::Self.new(call.line), call.name, true)
      end
      x.block = block
      x
    when AST::Return, AST::Next, AST::Break, AST::Yield
      call.value = AST::ArrayLiteral === args && args.body.size == 1 ? args.body.first : args
      call
    else
      raise call.inspect
    end
  end

  def to_assign(line, lhs, rhs=nil, op=nil)
    case lhs
    when AST::Send
      if lhs.vcall_style
        case op
        when 'and'
          AST::OpAssignAnd.new(line, lhs, rhs)
        when 'or'
          AST::OpAssignOr.new(line, lhs, rhs)
        else
          rhs = binop(line, op, AST::LocalVariableAccess.new(line, lhs.name), rhs) if op
          AST::LocalVariableAssignment.new(line, lhs.name, rhs)
        end
      else
        if op
          AST::OpAssign2.new(line, lhs.receiver, lhs.name, op.to_sym, rhs)
        else
          AST::AttributeAssignment.new(line, lhs.receiver, lhs.name, nil)
        end
      end
    when AST::SendWithArguments  # vcall
      if lhs.name == :[]
        if op
          AST::OpAssign1.new(line, lhs.receiver, lhs.arguments, op.to_sym, rhs)
        else
          AST::ElementAssignment.new(line, lhs.receiver, lhs.arguments)
        end
      end
    when AST::LocalVariableAccess
      rhs = binop(line, op, lhs, rhs) if op
      AST::LocalVariableAssignment.new(line, lhs.name, rhs)
    when AST::ConstantAccess
      rhs = binop(line, op, lhs.dup, rhs) if op
      AST::ConstantAssignment.new(line, lhs, rhs)
    when AST::ToplevelConstant, AST::ScopedConstant
      return nil if op
      AST::ConstantAssignment.new(line, lhs, rhs)
    when AST::InstanceVariableAccess
      rhs = binop(line, op, lhs, rhs) if op
      AST::InstanceVariableAssignment.new(line, lhs.name, rhs)
    when AST::ClassVariableAccess
      rhs = binop(line, op, lhs, rhs) if op
      AST::ClassVariableAssignment.new(line, lhs.name, rhs)
    when AST::GlobalVariableAccess, AST::BackRef
      rhs = binop(line, op, lhs, rhs) if op
      AST::GlobalVariableAssignment.new(line, lhs.name, rhs)
    when AST::CurrentException
      AST::GlobalVariableAssignment.new(line, :$!, rhs)
    end
  end

  def set_rhs(lhs, rhs)
    case lhs
    when AST::MultipleAssignment
      lhs.right = rhs
    when AST::ElementAssignment, AST::AttributeAssignment
      lhs.arguments.array << rhs
    else
      lhs.value = rhs
    end
    lhs
  end


  def deblockify(block)
    if block.array.size == 1
      block.array.first
    else
      block
    end
  end

  RESERVED = %w(
    __LINE__ __FILE__ BEGIN END alias and begin break case class def
    defined? do else elsif end ensure false for in module next nil not
    or redo rescue retry return self super then true undef when yield
    if unless while until
  )
}

eof = !.

space_element = hspace | newline | comment | escaped_newline
escaped_newline = "\\" newline
comment = /#[^\r\n]*/
hspace = /[ \t\v\f]+/

any_whitespace = /[ \t\n\r\n]/

wsp = space_element+
- = space_element*
sp = (hspace | comment | escaped_newline)+
s = (hspace | comment | escaped_newline)*


root = { setup } { line = lineno } rd_doc* program:r - eof { @ast = deblockify(r) }
program = statements

statements = - { line = lineno } stmts:s opt_terms { AST::Block.new(line, s) }

block_body = { l1 = lineno } statements:b - { l2 = lineno } (- rescue_clause)?:resc - else_clause?:els - { l3 = lineno } ensure_clause?:ens
               { b = AST::Rescue.new(l2, deblockify(b), resc, els) if resc || els; b = AST::Ensure.new(l3, deblockify(b), ens) if ens; b = AST::Block.new(l1, [b]) unless AST::Block === b; b }

stmts = stmts:l terms - statement:s { l + [s] }
      | statement:s { [s] }
      | none { [] }

statement = statement:v s { line = lineno } kw("if") - expr(Cx.new):c { AST::If.new(lineno, c, v, nil) }
          | statement:v s { line = lineno } kw("unless") - expr(Cx.new):c { AST::If.new(lineno, c, nil, v) }
          | statement:v s { line = lineno } kw("while") - expr(Cx.new):c { AST::While.new(lineno, c, v, !(AST::Begin === v)) }
          | statement:v s { line = lineno } kw("until") - expr(Cx.new):c { AST::Until.new(lineno, c, v, !(AST::Begin === v)) }
          | statement:v s { line = lineno } kw("rescue") - statement:f { AST::Rescue.new(line, v, AST::RescueCondition.new(line, nil, f, nil)) }
          | alias_statement:a { a }
          | { line = lineno } kw("undef") - undef_list(lineno):l { l.size == 1 ? l.first : AST::Block.new(line, l) }
          | { line = lineno } kw("BEGIN") - "{" - statements:s - "}"
          | { line = lineno } kw("END") - "{" - statements:s - "}"
          | { line = lineno } lhs(Cx.new):l s "=" !"=" !">" !"~" - mrhs:v { set_rhs(l, v) }
          | { line = lineno } mlhs:l s "=" !"=" !">" !"~" - mrhs:v { set_rhs(l, v) }
          | { line = lineno } lhs(Cx.new):l s "=" !"=" !">" !"~" - command_call(Cx.new):v { set_rhs(l, v) }
          | { line = lineno } mlhs:l s "=" !"=" !">" !"~" - command_call(Cx.new):v { set_rhs(l, AST::ToArray.new(line, v)) }
          | { line = lineno } mlhs:l s "=" !"=" !">" !"~" - arg(Cx.new):v { set_rhs(l, AST::ToArray.new(line, v)) }
          | { line = lineno } primary(Cx.new):t s op_asgn:o - command_call(Cx.new):v &{ x = to_assign(line,t,v,o) } { x }
          | expr(Cx.new):e { e }

alias_statement = { line = lineno } kw("alias") - fitem:a - fitem:b { AST::Alias.new(lineno, a, b) }
                | { line = lineno } kw("alias") - gvar:a - gvar:b { AST::VAlias.new(lineno, AST::SymbolLiteral.new(lineno, a.to_sym), AST::SymbolLiteral.new(lineno, b.to_sym)) }
                | { line = lineno } kw("alias") - gvar:a - backref:b { AST::VAlias.new(lineno, AST::SymbolLiteral.new(lineno, a.to_sym), AST::SymbolLiteral.new(lineno, b.to_sym)) } # FIXME: might be a n-ref, which should error

expr(cx) = { line = lineno } expr2(cx):l - kw("and") - expr(cx.right):r { AST::And.new(lineno,l,r) }
         | { line = lineno } expr2(cx):l - kw("or") - expr(cx.right):r { AST::Or.new(lineno,l,r) }
         | expr2(cx):e { e }
expr2(cx) = { line = lineno } kw("not") - expr2(cx.right):e { AST::Not.new(lineno,e) }
          | { line = lineno } "!" - expr2(cx.right):e { AST::Not.new(lineno,e) }
          | command_call(cx):c { c }
          | arg(cx):a { a }


command_call(cx) = !{ cx.no_do? } block_call(cx):t dot_or_colon - { line = lineno } operation2:n command_args(cx.right):a { x = AST::SendWithArguments.new(line, t, n.to_sym, a[0]); x.block = a[1]; x }
                 | !{ cx.no_do? } block_call(cx):c command_args(cx.right):a &{ command_candidate?(c) } { as_command(c, a[0],a[1]) }
                 | !{ cx.no_do? } block_call(cx):c { c }
                 | command(cx):c { c }
                 | kw("return") s command_call(cx.right):v { AST::Return.new(v) }
                 | kw("return") s loose_call_args(cx.right):v &{ v[0].nil? } { AST::Return.new(v[0]) }
                 | kw("break") s command_call(cx.right):v { AST::Break.new(v) }
                 | kw("break") s loose_call_args(cx.right):v &{ v[0].nil? } { AST::Break.new(v[0]) }
                 | kw("next") s command_call(cx.right):v { AST::Next.new(v) }
                 | kw("next") s loose_call_args(cx.right):v &{ v[0].nil? } { AST::Next.new(v[0]) }


cmd_brace_block = { line = lineno } "{" - opt_block_var:v - statements:s - "}" { AST::Iter.new(line, v, deblockify(b)) }

command(cx) = &{ false }
            | { line = lineno } kw("super") command_args(cx):v { x = AST::Super.new(line, v[0]); x.block = v[1]; x }
            | { line = lineno } kw("yield") command_args(cx):v { x = AST::Yield.new(line, v[0], true); x.block = v[1]; x }
            | primary(cx):c &{ command_candidate?(c) } command_args(cx):a (s cmd_brace_block)?:b &{ !a[1] || !b } { as_command(c, a[0], a[1] || b) }

mlhs = { line = lineno } "(" - mlhs:i - ")" { i }
     | { line = lineno } mlhs_head:l - mlhs_item:i { AST::MultipleAssignment.new(line, AST::ArrayLiteral.new(line, l + [i]), nil, nil) }
     | { line = lineno } mlhs_head:l - splat_lhs:i { AST::MultipleAssignment.new(line, AST::ArrayLiteral.new(line, l), nil, i) }
     | { line = lineno } mlhs_head:l { AST::MultipleAssignment.new(line, AST::ArrayLiteral.new(line, l), nil, nil) }
     | { line = lineno } splat_lhs:i { AST::MultipleAssignment.new(line, nil, nil, i) }

mlhs_head = mlhs_head:l - mlhs_item:i - "," { l + [i] }
          | mlhs_item:i - "," { [i] }

mlhs_item = "(" - mlhs:i - ")" { i }
          | mlhs_node(Cx.new):i { i }

mlhs_node(cx) = primary(cx):t &{ x = to_assign(t.line, t) } { x }

lhs(cx) = mlhs_node(cx)

cname = identifier
      | constant

cpath = primary(Cx.new):v &{ AST::ScopedConstant === v || AST::ToplevelConstant === v } ~v
      | constant:c { c.to_sym }

fname = fid
      | identifier:n "="?:q { q ? "#{n}=" : n }
      | constant:n "="?:q { q ? "#{n}=" : n }
      | < opmethod > { text }

fitem = { line = lineno } fname:n { AST::SymbolLiteral.new(line, n) }
      | symbol
      | dsym

undef_list(line) = undef_list(line):l s "," - fitem:i { l + [AST::Undef.new(line, i)] }
                 | fitem:i { [AST::Undef.new(line, i)] }

opmethod = "[]="
         | "[]"
         | "<=>"
         | "==="
         | "=="
         | "=~"
         | "<<"
         | ">>"
         | ">="
         | "<="
         | ">"
         | "<"
         | "+@"
         | "-@"
         | "**"
         | "+"
         | "-"
         | "*"
         | "/"
         | "%"
         | "~"
         | "|"
         | "^"
         | "&"
         | "`"

op_asgn = "||=" { 'or' }
        | "&&=" { 'and' }
        | < "**="
          | "*="
          | "<<="
          | ">>="
          | "&="
          | "|="
          | "+="
          | "-="
          | "/="
          | "^="
          | "%="
          > { text[0..-2] }

%% {
  def binop(line, op, lft, rgt)
    AST::SendWithArguments.new(line, lft, op, rgt)
  end
}

arg(cx) = { line = lineno } kw("defined?") - !"(" arg(cx.right):v ~defined_(v)
        | arg1(cx):c s { line = lineno } "?" - arg(cx.right):t - ":" - arg(cx.right):f { AST::If.new(line, c, t, f) }
        | arg1(cx)

arg1(cx) = arg2(cx):l s { line = lineno } ".." !"." - arg2(cx.right):r { AST::Range.new(line,l,r) }
         | arg2(cx):l s { line = lineno } "..." - arg2(cx.right):r { AST::RangeExclude.new(line,l,r) }
         | arg2(cx)

arg2(cx) = arg2(cx):l s { line = lineno } "||" !"=" - arg3(cx.right):r { AST::Or.new(line,l,r) }
         | arg3(cx)

arg3(cx) = arg3(cx):l s { line = lineno } "&&" !"=" - arg4(cx.right):r { AST::And.new(line,l,r) }
         | arg4(cx)

arg4(cx) = arg4(cx):l s { line = lineno } "<=>" - arg5(cx.right):r { binop(line,:<=>,l,r) }
         | arg4(cx):l s { line = lineno } "==" !"=" - arg5(cx.right):r { binop(line,:==,l,r) }
         | arg4(cx):l s { line = lineno } "===" - arg5(cx.right):r { binop(line,:===,l,r) }
         | arg4(cx):l s { line = lineno } "!=" - arg5(cx.right):r { binop(line,:"!=",l,r) }
         | arg4(cx):l s { line = lineno } "=~" - arg5(cx.right):r { binop(line,:"=~",l,r) }
         | arg4(cx):l s { line = lineno } "!~" - arg5(cx.right):r { binop(line,:"!~",l,r) }
         | arg5(cx)

arg5(cx) = arg5(cx):l s { line = lineno } ">" !"=" !">" - arg6(cx.right):r { binop(line,:>,l,r) }
         | arg5(cx):l s { line = lineno } ">=" - arg6(cx.right):r { binop(line,:>=,l,r) }
         | arg5(cx):l s { line = lineno } "<" !"=" !"<" - arg6(cx.right):r { binop(line,:<,l,r) }
         | arg5(cx):l s { line = lineno } "<=" !">" - arg6(cx.right):r { binop(line,:<=,l,r) }
         | arg6(cx)

arg6(cx) = arg6(cx):l s { line = lineno } "|" !"|" !"=" - arg7(cx.right):r { binop(line,:|,l,r) }
         | arg6(cx):l s { line = lineno } "^" !"=" - arg7(cx.right):r { binop(line,:^,l,r) }
         | arg7(cx)

arg7(cx) = arg7(cx):l s { line = lineno } "&" !"&" !"=" - arg8(cx.right):r { binop(line,:&,l,r) }
         | arg8(cx)

arg8(cx) = arg8(cx):l s { line = lineno } "<<" !"=" - arg9(cx.right):r { binop(line,:<<,l,r) }
         | arg8(cx):l s { line = lineno } ">>" !"=" - arg9(cx.right):r { binop(line,:>>,l,r) }
         | arg9(cx)

arg9(cx) = arg9(cx):l s { line = lineno } "+" !"=" - arg10(cx.right):r { binop(line,:+,l,r) }
         | arg9(cx):l s { line = lineno } "-" !"=" - arg10(cx.right):r { binop(line,:-,l,r) }
         | arg10(cx)

arg10(cx) = arg10(cx):l s { line = lineno } "*" !"*" !"=" - arg11(cx.right):r { binop(line,:*,l,r) }
          | arg10(cx):l s { line = lineno } "/" !"=" - arg11(cx.right):r { binop(line,:/,l,r) }
          | arg10(cx):l s { line = lineno } "%" !"=" - arg11(cx.right):r { binop(line,:%,l,r) }
          | arg11(cx)

arg11(cx) = { line = lineno } "-" !numeric arg11(cx.right):v { AST::Send.new(line, v, :-@) }
          | { line = lineno } !{ cx.strict? } !numeric "-" - arg11(cx.right):v { AST::Send.new(line, v, :-@) }
          | { line = lineno } "-" numeric:l s "**" !"=" - arg11(cx.right):r { AST::Send.new(line, binop(line,:**,l,r), :-@) }
          | arg12(cx)

arg12(cx) = arg13(cx):l s { line = lineno } "**" !"=" - arg11(cx.right):r { binop(line,:**,l,r) }
          | arg13(cx)

arg13(cx) = { line = lineno } "!" - arg11(cx.right):v { AST::Send.new(line, v, :"!") }
          | { line = lineno } "~" - arg11(cx.right):v { AST::Send.new(line, v, :~) }
          | { line = lineno } "+" arg11(cx.right):v { AST::Send.new(line, v, :+@) }
          | { line = lineno } !{ cx.strict? } "+" - arg11(cx.right):v { AST::Send.new(line, v, :+@) }
          | lhs(cx):l s { line = lineno } "=" !"=" !">" !"~" - arg(cx.right):v s kw("rescue") - arg(cx.right):r { set_rhs(l, AST::Rescue.new(line, v, AST::RescueCondition.new(line, nil, r, nil))) }
          | lhs(cx):l s { line = lineno } "=" !"=" !">" !"~" - arg(cx.right):v { set_rhs(l, v) }
          | primary(cx):t s { line = lineno } op_asgn:o - arg(cx.right):v &{ x = to_assign(line, t, v, o) } { x }
          | primary(cx)


aref_args = { line = lineno } assocs(Cx.new):l (- ",")? &(- "]") { AST::HashLiteral.new(line, l) }
          | { line = lineno } "*" arg(Cx.new):s &(- "]") { AST::SplatValue.new(line, s) }
          | { line = lineno } command(Cx.new):v &(- "]") { v }
          | { line = lineno } args(Cx.new):l - "," - "*" arg(Cx.new):s &(- "]") { AST::ConcatArgs.new(line, AST::ArrayLiteral.new(line, l), s) }
          | { line = lineno } args(Cx.new):l (- ",")? &(- "]") { AST::ArrayLiteral.new(line, l) }
          | none &(- "]") { nil }

paren_args = "(" - ")" { [nil, nil] }
           | { line = lineno } "(" - call_args(Cx.new):a - ")" { a }
           | { line = lineno } "(" - block_call(Cx.new):b - ")" { [b, nil] }
           | { line = lineno } "(" - args(Cx.new):a - "," - block_call(Cx.new):b - ")" { [AST::ArrayLiteral.new(lineno, a + [b]), nil] }
           | sp paren_args:a { a }

loose_call_args(cx) = !kw("if") !kw("unless") !kw("while") !kw("until") call_args(cx.strict):a ~a
call_args(cx) = &{false} # command(cx):c { [c] }
              | { line = lineno } assocs(cx):h s "," - "*" arg(cx.right):s opt_block_arg(cx.right):b { [AST::ConcatArgs.new(line, AST::HashLiteral.new(line, h), s), b] }
              | { line = lineno } assocs(cx):h opt_block_arg(cx.right):b { [AST::HashLiteral.new(line, h), b] }
              | { line = lineno } args(cx):a s "," - assocs(cx.right):h s "," - "*" arg(cx.right):s opt_block_arg(cx.right):b { [AST::ConcatArgs.new(line, AST::ArrayLiteral.new(line, a + [AST::HashLiteral.new(line, h)]), s), b] }
              | { line = lineno } args(cx):a s "," - assocs(cx.right):h opt_block_arg(cx.right):b { [AST::ArrayLiteral.new(line, a + [AST::HashLiteral.new(line, h)]), b] }
              | { line = lineno } args(cx):a s "," - "*" arg(cx.right):s opt_block_arg(cx.right):b { [AST::ConcatArgs.new(line, AST::ArrayLiteral.new(line, a), s), b] }
              | { line = lineno } arg(cx):i s "," - args(cx.right):a opt_block_arg(cx.right):b { [AST::ArrayLiteral.new(line, [i] + a), b] }
              | command(cx):c { [c, nil] }
              | { line = lineno } args(cx):a opt_block_arg(cx.right):b { [AST::ArrayLiteral.new(line, a), b] }
              | { line = lineno } "*" arg(cx.right):s opt_block_arg(cx.right):b { [AST::SplatValue.new(line, s), b] }
              | block_arg(cx):b { [nil, b] }


command_args(cx) = !"(" !"[" !"{" !"/" !"%" !"-" !"+" !"<<" s loose_call_args(cx):a { a }

block_arg(cx) = { line = lineno } "&" - arg(cx.right):v { AST::BlockPass.new(line, v) }
opt_block_arg(cx) = - "," - block_arg(cx):v { v }
              | none { nil }

args(cx) = args(cx):l s "," - arg(cx.right):v !(s "=>") { l + [v] }
         | arg(cx):v !(s "=>") { [v] }

mrhs = { line = lineno } args(Cx.new):l &{ l.size > 1 } { AST::ArrayLiteral.new(line, l) }
     | { line = lineno } args(Cx.new):l s "," - "*" arg(cx.right):v { AST::ConcatArgs.new(line, l, v) }
     | { line = lineno } "*" arg(cx.right):v { AST::SplatValue.new(line, v) }


primary(cx) = primary(cx):t "[" - aref_args:a - "]" { AST::SendWithArguments.new(lineno, t, :[], a) }
            | { line = lineno } primary(cx):t dot_or_colon - operation2:n paren_args:a s brace_block(cx.right):b &{ a[1].nil? } { x = AST::SendWithArguments.new(lineno, t, n.to_sym, a[0]); x.block = b; x }
            | { line = lineno } primary(cx):t dot_or_colon - operation2:n s brace_block(cx.right):b { x = AST::Send.new(lineno, t, n.to_sym); x.block = b; x }
            | { line = lineno } primary(cx):t dot_or_colon - operation2:n paren_args:a { x = AST::SendWithArguments.new(lineno, t, n.to_sym, a[0]); x.block = a[1]; x }
            | { line = lineno } primary(cx):t dot_or_colon - operation3:n { AST::Send.new(lineno, t, n.to_sym) }
            | { line = lineno } primary(cx):t "::" - constant:c { AST::ScopedConstant.new(lineno, t, c.to_sym) }
            | { line = lineno } primary(cx):t s "." - constant:c { AST::Send.new(lineno, t, c.to_sym) }
            | { line = lineno } operation:n paren_args:a s brace_block(cx.right):b &{ a[1].nil? } { x = AST::SendWithArguments.new(lineno, AST::Self.new(lineno), n.to_sym, a[0], true); x.block = b; x }
            | { line = lineno } operation:n paren_args:a { x = AST::SendWithArguments.new(lineno, AST::Self.new(lineno), n.to_sym, a[0], true); x.block = a[1]; x }
            | { line = lineno } operation:n s brace_block(cx.right):b { x = AST::Send.new(lineno, AST::Self.new(lineno), n.to_sym, true); x.block = b; x }
            | { line = lineno } kw("super") paren_args:v s brace_block(cx.right):b &{ a[1].nil? } { x = AST::Super.new(lineno, v[0]); x.block = b; x }
            | { line = lineno } kw("super") paren_args:v { x = AST::Super.new(lineno, v[0]); x.block = v[1]; x }
            | { line = lineno } kw("super") s brace_block(cx.right):b { x = AST::ZSuper.new(lineno); x.block = b; x }
            | { line = lineno } kw("super") { AST::ZSuper.new(lineno) }
            | literal
            | strings(cx)
            | xstring
            | regexp(cx)
            | words
            | qwords
            | { line = lineno } !"defined?" fid:n { AST::Send.new(lineno, AST::Self.new(lineno), n.to_sym, true) }
            | variable
            | { line = lineno } kw("begin") - block_body:b - kw("end") { AST::Begin.new(line, deblockify(b)) }
            | "(" - expr(Cx.new):e - ")" { e }
            | { line = lineno } "(" - statements:s - ")" { AST::Block.new(lineno, s) }
            | { line = lineno } "::" - constant:c { AST::ToplevelConstant.new(lineno, c.to_sym) }
            | { line = lineno } "[" - aref_args:a - "]" { AST::ArrayLiteral.new(lineno, a) }
            | { line = lineno } "{" - assoc_list:l - "}" { AST::HashLiteral.new(lineno, l) }
            | { line = lineno } kw("return") { AST::Return.new(lineno, nil) }
            | { line = lineno } kw("yield") s "(" - call_args(Cx.new):v - ")" { x = AST::Yield.new(lineno, v[0], true); x.block = v[1]; x }
            | { line = lineno } kw("yield") s "(" - ")" { AST::Yield.new(lineno, nil, false) }
            | { line = lineno } kw("yield") { AST::Yield.new(lineno, nil, false) }
            | { line = lineno } kw("defined?") - "(" - expr(Cx.new):v - ")" { AST::Defined.new(lineno, v) }
            | { line = lineno } kw("if") - expr(cx.right):e s then - statements:s - if_tail(cx.right):l - kw("end") { AST::If.new(lineno, e, deblockify(s), l) }
            | { line = lineno } kw("unless") - expr(cx.right):e s then - statements:s - else_clause?:f - kw("end") { AST::If.new(lineno, e, f, deblockify(s)) }
            | { line = lineno } kw("while") - expr(Cx.no_do):e s do - statements:s - kw("end") { AST::While.new(lineno, e, s, true) }
            | { line = lineno } kw("until") - expr(Cx.no_do):e s do - statements:s - kw("end") { AST::Until.new(lineno, e, s, true) }
            | { line = lineno } kw("case") opt_terms - case_body:b - else_clause?:e - kw("end") { AST::Case.new(lineno, b, e) }
            | { line = lineno } kw("case") - expr(cx.right):v opt_terms - case_body:b - else_clause?:e - kw("end") { AST::ReceiverCase.new(lineno, v, b, e) }
            | { line = lineno } kw("for") - for_var:a - kw("in") - expr(cx.right):t s do - statements:b - kw("end") { x = AST::Send.new(lineno, t, :each); x.block = AST::For.new(lineno, a, b); x }
            | { line = lineno } kw("class") - "<<" - expr(cx.right):e term - block_body:b - kw("end") { AST::SClass.new(lineno, e, b) }
            | { line = lineno } kw("class") - cpath:n superclass:s - block_body:b - kw("end") { AST::Class.new(lineno, n, s, b) }
            | { line = lineno } kw("module") - cpath:n - block_body:b - kw("end") { AST::Module.new(lineno, n, b) }
            | { line = lineno } kw("def") - fname:n s f_arglist:a - block_body:b - kw("end") { x = AST::Define.new(lineno, n.to_sym, b); x.arguments = a; x }
            | { line = lineno } kw("def") - singleton:o dot_or_colon - fname:n s f_arglist:a - block_body:b - kw("end") { x = AST::DefineSingleton.new(lineno, o, n.to_sym, b); x.body.arguments = a; x }
            | { line = lineno } kw("break") { AST::Break.new(lineno, nil) }
            | { line = lineno } kw("next") { AST::Next.new(lineno, nil) }
            | { line = lineno } kw("redo") { AST::Redo.new(lineno) }
            | { line = lineno } kw("retry") { AST::Retry.new(lineno) }

then = ":"
     | kw("then")
     | term - kw("then")
     | term

do = term
   | ":"
   | kw("do")

if_tail(cx) = { line = lineno } kw("elsif") - expr(cx.right):c s then - statements:s - if_tail(cx):l { AST::If.new(lineno, c, deblockify(s), l) }
            | else_clause:e { e }
            | none { nil }

else_clause = kw("else") - statements:s { deblockify(s) }

for_var = mlhs
        | lhs(Cx.new)

block_var = { line = lineno } mlhs_head:l - mlhs_item:i { AST::MultipleAssignment.new(line, AST::ArrayLiteral.new(line, l + [i]), nil, nil) }
          | { line = lineno } mlhs_head:l - splat_lhs:i - "," - "&" - lhs(Cx.new):b  { x = AST::MultipleAssignment.new(line, AST::ArrayLiteral.new(line, l), nil, i); x.block = b; x }
          | { line = lineno } mlhs_head:l - "&" - lhs(Cx.new):b { x = AST::MultipleAssignment.new(line, AST::ArrayLiteral.new(l), nil, nil); x.block = b; x }
          | { line = lineno } splat_lhs:i - "&" - lhs(Cx.new):b { x = AST::MultipleAssignment.new(line, nil, nil, i); x.block = b; x }
          | { line = lineno } "&" - lhs(Cx.new):b { x = AST::MultipleAssignment.new(line, nil, nil, i); x.block = b; x }
          | { line = lineno } mlhs_head:l - splat_lhs:i { AST::MultipleAssignment.new(line, AST::ArrayLiteral.new(line, l), nil, i) }
          | { line = lineno } mlhs_head:l { AST::MultipleAssignment.new(line, AST::ArrayLiteral.new(line, l), nil, nil) }
          | { line = lineno } splat_lhs:i { AST::MultipleAssignment.new(line, nil, nil, i) }
          | { line = lineno } mlhs_item:i { i }
          | none { 0 }

splat_lhs = "*" - lhs(Cx.new):s { s }
          | "*" { true }

opt_block_var = "|" - block_var:v - "|" { v }
              | none { nil }

do_block = kw("do") - opt_block_var:v - statements:b - kw("end") { AST::Iter.new(lineno, v, deblockify(b)) }

block_call(cx) = block_call(cx):t dot_or_colon - { line = lineno } operation2:n paren_args:a { x = AST::SendWithArguments.new(line, t, n.to_sym, a[0]); x.block = a[1]; x }
               | block_call(cx):t dot_or_colon - { line = lineno } operation2:n { AST::Send.new(line, t, n.to_sym) }
               | command(cx):c s do_block:b { c.block = b; c }


brace_block(cx) = "{" - opt_block_var:v - statements:b - "}" { AST::Iter.new(lineno, v, deblockify(b)) }
                | !{ cx.no_do? } kw("do") - opt_block_var:v - statements:b - kw("end") { AST::Iter.new(lineno, v, deblockify(b)) }

when_clause = { line = lineno } kw("when") - when_args:a s then - statements:s { AST::When.new(line, a, deblockify(s)) }

case_body = when_clause:w - case_body:l { [w] + l }
          | when_clause:w { [w] }

when_args = { line = lineno } args(Cx.new):a - "," - "*" arg(Cx.new):s { AST::ArrayLiteral.new(line, a + [AST::When.new(line, s, nil)]) }
          | { line = lineno } args(Cx.new):a { AST::ArrayLiteral.new(line, a) }
          | { line = lineno } "*" arg(Cx.new):s { AST::ArrayLiteral.new(line, [AST::When.new(line, s, nil)]) }

rescue_clause = kw("rescue") s exc_list?:l s exc_var:v s then - statements:s (- rescue_clause)?:n { s.array.unshift(v) if v; AST::RescueCondition.new(lineno, l && AST::ArrayLiteral.new(lineno, l), s, n) }

exc_list = exc_list:l s "," - arg(Cx.new):i { l + [i] }
         | arg(Cx.new):i { [i] }

exc_var = "=>" - lhs(Cx.new):v { set_rhs(v, AST::CurrentException.new(v.line)) }
        | none { nil }

ensure_clause = kw("ensure") - statements:s { s }


literal = numeric
        | symbol:s
        | dsym:s
        | { line = lineno } char:c { AST::FixnumLiteral.new(line, c) }
char = "?" &"\\" char_escape:c { c }
     | "?" !any_whitespace <.> { text[0] }
char_escape = "\\\\" { ?\\ }
            | "\\x" </[0-9A-Fa-f]{2}/> { text.to_i(16) }
            | ("\\c" | "\\C-") char_escape:c { (c & 0x9f) }
            | ("\\c" | "\\C-") <.> { (text[0] & 0x9f) }
            | "\\M-" char_escape:c { (c | 0x80) }
            | "\\M-" <.> { (text[0] | 0x80) }
            | "\\" /[xcCM]/ { nil }
            | "\\" </[0-7]+/> { text.to_i(8) }
            | "\\" <.> { escaped_char(text) }


strings(cx) = { line = lineno } string:s { AST.str(lineno, s) }
            | { line = lineno } "%Q" nesting_string(true):s { AST.str(lineno, s) }
            | { line = lineno } "%q" nesting_string(false):s { AST.str(lineno, s) }
            | { line = lineno } "%" !"=" !any_whitespace nesting_string(true):s { AST.str(lineno, s) }
            | { line = lineno } !{ cx.strict? } "%=" qstring(["="]):s "=" { AST.str(lineno, s) }
            | "<<" <"-"?> heredoc_ref(text):r { r }

heredoc_ref(indent) = { line = lineno } "'" < /[^']+/ > "'" { heredoc(lineno, text, indent != '') }
                    | { line = lineno } "\"" < /[^"]+/ > "\"" { heredoc(lineno, text, indent != '', AST::DynamicString) }
                    | { line = lineno } "`" < /[^`]+/ > "`" { heredoc(lineno, text, indent != '', AST::DynamicExecuteString) }
                    | { line = lineno } < word > { heredoc(lineno, text, indent != '', AST::DynamicString) }

string = string:a s string1:b { a+b }
       | string1

string1 = "\"" qstring(["\""]):s "\"" { s }
        | "'" lstring(["'"], true):s "'" { s }

xstring = "`" qstring(["`"]):s "`" { AST.str(lineno, s, AST::ExecuteString, AST::DynamicExecuteString) }
        | "%x" nesting_string(true):s { AST.str(lineno, s, AST::ExecuteString, AST::DynamicExecuteString) }

regexp(cx) = "/" !"=" !any_whitespace qstring(["/"]):s "/" re_flags:f { AST.str(lineno, s, AST::RegexLiteral, f =~ /o/ ? AST::DynamicOnceRegex : AST::DynamicRegex, regex_flags(f)) }
               | !{ cx.strict? } "/" qstring(["/"]):s "/" re_flags:f { AST.str(lineno, s, AST::RegexLiteral, f =~ /o/ ? AST::DynamicOnceRegex : AST::DynamicRegex, regex_flags(f)) }
               | "%r" nesting_string(true):s re_flags:f { AST.str(lineno, s, AST::RegexLiteral, f =~ /o/ ? AST::DynamicOnceRegex : AST::DynamicRegex, regex_flags(f)) }

re_flags = < /[A-Za-z]*/ > { text }

words = { line = lineno } "%w" </[^A-Za-z0-9]/> { strend = string_end(text) } word_list(false, text, strend, 0)?:w &{ w[0] == 0 } <.> &{ text == strend } { w ? AST::ArrayLiteral.new(lineno, w[1]) : AST::EmptyArray.new(lineno) }
qwords = { line = lineno } "%W" </[^A-Za-z0-9]/> { strend = string_end(text) } word_list(true, text, strend, 0)?:w &{ w[0] == 0 } <.> &{ text == strend } { w ? AST::ArrayLiteral.new(lineno, w[1]) : AST::EmptyArray.new(lineno) }

word_space = newline
           | " "
           | "\t"
           | "\v"
           | "\f"

word_part(q,lft,rgt,d) = &{ lft != rgt } word_part(q,lft,rgt,d):a word_part(q,lft,rgt,a[0]):b { [b[0], a[1] + b[1]] }
                       | &{ lft != rgt } <.> &{ text == lft } { [d + 1, [lft]] }
                       | &{ lft != rgt } <.> &{ d > 0 && text == rgt } { [d - 1, [rgt]] }
                       | !{ q } lstring(SPACES + [lft, rgt], true):i { [d, i] }
                       | &{ q } qstring(SPACES + [lft, rgt]):i { [d, i] }
word_list(q,lft,rgt,d) = { line = lineno } word_part(q,lft,rgt,d):i word_space+ word_list(q,lft,rgt,i[0]):l { [l[0], [AST.str(lineno,i[1])] + l[1]] }
                       | { line = lineno } word_part(q,lft,rgt,d):i { [i[0], [AST.str(lineno,i[1])]] }

nesting_string(q) = </[^A-Za-z0-9]/> { strend = string_end(text) } nesting_string_part(q,text,strend)?:s <.> &{ text == strend } { s || [] }
nesting_string_part(q,lft,rgt) = &{ lft != rgt } nesting_string_part(q,lft,rgt):a nesting_string_part(q,lft,rgt):b { a + b }
                               | &{ lft != rgt } <.> &{ text == lft } nesting_string_part(q,lft,rgt):i <.> &{ text == rgt } { [lft] + i + [rgt] }
                               | !{ q } lstring([lft, rgt], true):i { i }
                               | &{ q } qstring([lft, rgt]):i { i }

lstring(stops,escapes) = lstring_item(stops,escapes)*:s { s }
lstring_item(stops,escapes) = !{ stops.include?("\\") } &{ stops.include?("\n") } "\\" newline:nl { nl }
                            | !{ stops.include?("\\") } "\\" < . > &{ stops.include?(text) } { text }
                            | !{ stops.include?("\\") } "\\\\" &{ escapes } { "\\" }
                            | !{ stops.include?("\n") } newline:nl { nl }
                            | < . > !{ stops.include?(text) } { text }

qstring(stops) = qstring_item(stops)*:s { s }
qstring_item(stops) = !{ stops.include?("\\") } "\\" newline { "" }
                    | !{ stops.include?("\\") } &"\\" char_escape:c { c.chr }
                    | !{ stops.include?('#') } "#" dyn_string_part:d { d }
                    | !{ stops.include?("\n") } newline:nl { nl }
                    | < . > !{ stops.include?(text) } { text }

dyn_string_part = { line = lineno } cvar:n { AST::ClassVariableAccess.new(line, n.to_sym) }
                | { line = lineno } ivar:n { AST::InstanceVariableAccess.new(line, n.to_sym) }
                | { line = lineno } backref:n { AST::BackRef.new(line, n.to_sym) }
                | { line = lineno } gvar:n { AST::GlobalVariableAccess.for_name(line, n.to_sym) }
                | "{" - statements:s - "}" { deblockify(s) }


symbol = { line = lineno } ":" sym:s { AST::SymbolLiteral.new(line, s.to_sym) }
sym = fname
    | cvar
    | ivar
    | gvar
    | backref

dsym = ":" string1:s { AST.str(lineno, s, AST::SymbolLiteral, AST::DynamicSymbol) do |x| x.to_sym end}
     | "%s" nesting_string(false):s { AST.str(lineno, s, AST::SymbolLiteral, AST::DynamicSymbol) do |x| x.to_sym end}

numeric = { line = lineno } float:n { AST::FloatLiteral.new(lineno, n) }
        | { line = lineno } integer:n { Fixnum === n ? AST::FixnumLiteral.new(lineno, n) : AST::NumberLiteral.new(lineno, n) }

integer = "-"?:neg "0" ("x" | "X") < /[0-9A-Fa-f]+/ ("_" /[0-9A-Fa-f]+/)* > { n = text.gsub('_','').to_i(16); (neg ? -n : n) }
        | "-"?:neg "0" ("d" | "D") < /[0-9]+/ ("_" /[0-9]+/)* > { n = text.gsub('_','').to_i(10); (neg ? -n : n) }
        | "-"?:neg "0" ("b" | "B") < /[0-1]+/ ("_" /[0-1]+/)* > { n = text.gsub('_','').to_i(2); (neg ? -n : n) }
        | "-"?:neg "0" ("o" | "O")? < /[0-7]+/ ("_" /[0-7]+/)* > { n = text.gsub('_','').to_i(8); (neg ? -n : n) }
        | "-"? "0" { 0 }
        | < /-?[1-9][0-9]*/ ("_" /[0-9]+/)* > { (text.gsub('_','').to_i(10)) }

         float = < /-?[0-9]+/ ("_" /[0-9]+/)* (/\.[0-9]+/ ("_" /[0-9]+/)* float_exponent? | float_exponent) > { text.gsub('_','').to_f }
float_exponent = /[eE][-+]?[0-9]+/ ("_" /[0-9]+/)*

variable = { line = lineno } name:n { AST::Send.new(line, AST::Self.new(line), n.to_sym, true, true) }
         | { line = lineno } cvar:n { AST::ClassVariableAccess.new(line, n.to_sym) }
         | { line = lineno } ivar:n { AST::InstanceVariableAccess.new(line, n.to_sym) }
         | { line = lineno } gvar:n { AST::GlobalVariableAccess.for_name(line, n.to_sym) }
         | { line = lineno } backref:n { AST::BackRef.new(line, n.to_sym) }
         | { line = lineno } constant:c { AST::ConstantAccess.new(lineno, c.to_sym) }
         | { line = lineno } kw("nil") { AST::NilLiteral.new(lineno) }
         | { line = lineno } kw("self") { AST::Self.new(lineno) }
         | { line = lineno } kw("true") { AST::TrueLiteral.new(lineno) }
         | { line = lineno } kw("false") { AST::FalseLiteral.new(lineno) }
         | { line = lineno } kw("__FILE__") { AST::File.new(lineno) }
         | { line = lineno } kw("__LINE__") { AST::FixnumLiteral.new(lineno, line) }

backref = "$" /[&`'+]|[1-9][0-9]*/

superclass = s "<" - expr(Cx.new):e term { e }
           | term { nil }

f_arglist = "(" - f_args:a - ")" { a }
          | f_args:a term { a }

f_args_tail = f_optarg:o - "," - f_rest_arg:s { [o.map {|x| x.name }, o, s] }
            | f_optarg:o { [o.map {|x| x.name }, o, nil] }
            | f_rest_arg:s { [[], [], s] }
            | f_norm_arg:n - "," - f_args_tail:l { [[n] + l[0], l[1], l[2]] }
            | f_norm_arg:n { [[n], [], nil] }

f_args = { line = lineno } f_args_tail:l opt_f_block_arg:b { defs = nil; defs = AST::Block.new(line, l[1]) if l[1].size > 0; x = AST::FormalArguments.new(line, l[0], defs, l[2]); x.block_arg = b if b; x }
       | { line = lineno } f_block_arg:b { x = AST::FormalArguments.new(line, [], nil, nil); x.block_arg = b; x }
       | none { [] }

f_norm_arg = constant { error }
           | cvar { error }
           | ivar { error }
           | gvar { error }
           | name:n { n.to_sym }

constant = < /[A-Z](?:[A-Za-z0-9_]|[^\0-\177])*/ > { text }
cvar = < "@@" word > { text }
ivar = < "@" word > { text }
gvar = < "$" word > { text }
     | < "$" /[0~*$?!@;,.=:<>\/\\"]/ > { text }
     | < "$-" /[A-Za-z0-9]/ > { text }

f_opt = { line = lineno } name:n - "=" - arg(Cx.new):v { AST::LocalVariableAssignment.new(line, n.to_sym, v) }

f_optarg = f_optarg:l - "," - f_opt:a { l + [a] }
         | f_opt:a { [a] }

f_rest_arg = "*" name:n { n.to_sym }
           | "*" { true }

f_block_arg = { line = lineno } "&" name:n { AST::BlockArgument.new(line, n.to_sym) }
opt_f_block_arg = - "," - f_block_arg:b { b }
                | none { nil }

singleton = variable:v { v }
          | "(" - expr(Cx.new):e - ")" { e }

assoc_list = assocs(Cx.new):a trailer { a }
           | args(Cx.new):a trailer { a }
           | none { [] }

assocs(cx) = assocs(cx):l - "," - assoc(cx.right):x { l + x }
               | assoc(cx):x { x }

assoc(cx) = arg(cx):k - "=>" - arg(cx.right):v { [k,v] }

operation = !"defined?" fid:f { f }
          | name:i { i }
          | constant:c { c }

operation2 = fid:f { f }
           | identifier:i { i }
           | constant:c { c }
           | < opmethod > { text }

operation3 = fid:f { f }
           | identifier:i { i }
           | < opmethod > { text }

identifier = < /(?:[a-z_]|[^\0-\177])(?:[A-Za-z0-9_]|[^\0-\177])*/ > { text }
name = < (fid | identifier) > !{ RESERVED.include?(text) } { text }

word = < /(?:[A-Za-z_]|[^\0-\177])(?:[A-Za-z0-9_]|[^\0-\177])*/ > { text }

kw(w) = < word /[?!]?/ > &{ text == w } { w }

fid = < /[A-Za-z0-9_]+[!?]/ > { text }

dot_or_colon = s "."
             | "::"

newline = < ("\r" "\n"? | "\n") > @pending_heredocs rd_doc* { text }
rd_doc = "=begin" (!"=end" /[^\r\n]*(?:\r\n?|\n)/)+ "=end" /[^\r\n]*(?:\r\n?|\n)/

pending_heredocs = &{ h = pop_heredoc } @pending_heredocs heredoc(h)
                 | &{ true }
heredoc_stop(h) = < (/[^\r\n]*(?:\r\n?|\n)/ | /[^\r\n]*/ eof) > &{ h.stop?(text) }
heredoc_line(h) = &{ h.dynamic } !heredoc_stop(h) qstring(NEWLINE):items newline:nl { items + [nl] }
                | !{ h.dynamic } !heredoc_stop(h) lstring(NEWLINE, false):items newline:nl { items + [nl] }
heredoc(h) = heredoc_line(h)*:lines (heredoc_stop(h) | fail(h)) { h.append(lines); nil }

trailer = (newline | ",")?

opt_terms = terms?
term = s ";" | s newline
terms = terms s ";"
      | term

none = &{ true }

fail(s) = { raise "Parse failed: #{s.inspect}" }
dbg = &debug(nil)
debug(s) = </(\n|\r|.){0,20}/> { ls = caller.map {|x| x.sub!(::Regexp.new(".*`_(.*)'$"), '\1') }.compact; ls.shift if ls.first == 'dbg'; px = ls.first; p ls; px = px+": #{s}" if s; puts "#{px}: #{text.inspect}" }

